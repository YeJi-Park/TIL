### Object: OOP

#### Ch07. 객체 분해

추상화: 한 번에 모든 정보를 다 가지고 있을 수는 없기 때문에 **불필요한 정보를 제거하고 본질적인 정보만 남기는 작업**

	- 분해: 큰 문제를 해결 가능한 작은 문제로 나누는 추상화의 한 방법

##### 01. 프로시저 추상화와 데이터 추상화

- 프로그래밍 언어의 발전은 효과적인 추상화를 이용해 복잡성을 극복하려는 노력에서 시작

  → 다양한 프로그래밍 패러다임의 탄생

- 현대적인 프로그래밍 언어의 추상화 메커니즘은 2가지로 특징지을 수 있음

  1. 프로시저 추상화: SW가 무엇을 해야하는지를 추상화
     - 기능 분해/알고리즘 분해
  2. 데이터 추상화: SW가 무엇을 알아야 하는지를 추상화
     - 타입 추상화: **추상 데이터 타입**
     - 데이터를 중심으로 프로시저를 추상화: **객체지향**

---

##### 02. 프로시저 추상화와 기능 분해

###### 메인 함수로서의 시스템

- 기능은 오랜 시간 동안 시스템 분해의 기준으로 사용되어 왔음 (알고리즘 분해/기능 분해)
  - 추상화의 단위: 프로시저, 시스템도 프로시저 단위로 분해됨

- 프로시저: 반복적으로 실행되거나 유사하게 실행되는 작업을 하나의 장소에 모아 로직을 재사용하는 추상화 방법
  - 구현 내용을 모르더라도 인터페이스를 알면 프로시저를 사용할 수 있음(정보 은닉)
  - 전통적인 기능 분해 방법은 **하향식 접근법**을 따름
    - 가장 추상적인 최상위 기능을 정의하고 구체적이고 작은 단계의 기능으로 분해

###### 급여 관리 시스템

- 요구사항

  - 회사가 연초에 매달 지급해야 하는 기본급을 직원과 협의하여 12개월 동안 직원들에게 지급

  - 회사는 세율에 따라 일정 금액의 세금을 공제 후 지불함

    > 급여 = 기본급 - (기본급*소득세율)

- **직원의 급여를 계산한다**를 메인 프로시저로 하여, 구체적인 세부 기능으로 분해할 것

- 분해 전

  > - 직원의 급여를 계산한다

- 분해 후

  > - 직원의 급여를 계산한다
  >   - 사용자로부터 소득세율을 입력받는다
  >   - 직원의 급여를 계산한다
  >   - 양식에 맞게 결과를 출력한다

<br>

- 구체화된 단계는 이전 문장보다 단순하고 구체적인 문장이어야 함
  - 더 구체화될 수 있는 문장이 존재하면 구현이 가능할 정도로 저수준의 문장이 될 때까지 기능을 분해

분해 후

> - 직원의 급여를 계산한다
>   - 사용자로부터 소득세율을 입력받는다
>     - "세율을 입력하세요: " 라는 문장을 화면에 출력한다
>     - 키보드를 통해 세율을 입력받는다
>   - 직원의 급여를 계산한다
>     - 직원의 기본급 정보를 얻는다
>     - 급여를 계산한다
>   - 양식에 맞게 결과를 출력한다
>     - "이름: {}, 급여{}" 형식에 따라 출력 문자열을 생성한다

- 기능 분해의 결과는 최상위 기능을 수행하는 데 필요한 절차들을 실행되는 시간 순서에 따라 나열한 것
- 기능 분해 방법에서는 **기능을 중심으로 필요한 데이터를 결정**

###### 급여 관리 시스템 구현

- 하향식 기능 분해는 시스템을 최상위 추상적인 메인 함수로 정의함
  - 메인 함수를 루트로, 프로시저가 각 노드로 표현되는 트리로 나타낼 수 있음
- 하향식 기능 분해의 문제점
  - 너무 이른 시기에 함수들을 결정하기 때문에 변경에 대비하기 어려움

###### 하나의 메인 함수라는 비현실적인 아이디어

- 시간이 지나고 새로운 요구사항이 생기고 새로운 기능이 추가되면, 하나의 메인함수로는 감당하기 어려움
- 대부분의 경우 추가 기능은 메인 함수의 일부가 아니기 때문에 메인 함수는 여러 함수 중 하나일 뿐이 됨
- 하나의 알고리즘이나 배치 처리에는 적합하나 현대적인 상호작용 시스템을 개발하기에는 적합하지 않음
- **실제 시스템에 정상(top)이란 존재하지 않는다!**

###### 메인 함수의 빈번한 재설계

- 하나의 메인 함수를 정상으로 간주하는 하향식 기능은 새로운 기능이 추가되면 메인 함수를 수정해야 함
  - 기존 로직과는 상관없는 새로운 함수가 추가되는 것이기 때문에 메인 함수의 구조가 급격히 변경됨
  - 코드 수정은 버그를 만들어낼 확률을 높이기 때문에 주의해야 함

###### 비즈니스 로직과 사용자 인터페이스의 결합

- 초기 단계부터 입/출력을 고민하게 만듦→코드 안에서 비즈니스 로직과 UI 로직이 결합됨
- 둘은 변경되는 빈도가 다르기 때문에 변경에 불안정한 아키텍처가 됨

###### 성급하게 결정된 실행 순서

- 하향식으로 분해하는 과정에서 시스템이 무엇이 아니라 어떻게HOW 동작하는지 집중하게 됨

- 초기부터 구현을 염두에 두기 때문에 함수의 실행 순서를 정의하는 시간 제약을 강조하게 됨

  → 중앙집중 제어 스타일의 형태가 되어 변경이 일어날 때마다 제어구조 전체가 변경되어야 함

- **결합도**가 높은 함수라는 것이 문제

###### 데이터 변경으로 인한 파급효과

- 어떤 데이터를 어떤 함수가 사용하는지 알 수 없기 때문에 데이터가 변경되면 어떤 함수가 영향을 받을지 알 수 없음

  → 의존성과 결합도의 문제

###### 언제 하향식 분해가 유용한가?

- 작은 프로그램과 개별 알고리즘을 위해서는 유용한 패러다임임
- 이미 해결된 알고리즘을 문서화하는 데에는 효과적인 기법이지만 소프트웨어를 설계하는 데에 적합하지 않음

----

##### 03. 모듈

###### 정보 은닉과 모듈

- 정보은닉: 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스로 감춤
  - 시스템 분해의 기본 원칙
- 모듈은 변경될 가능성이 있는 부분을 내부로 감추고 잘 변경되지 않는 인터페이스를 외부에 제공해 내부의 비밀에 함부로 접근하지 못하게 함
- **모듈과 기능 분해는 상호 배타적이지 않음**, 모듈로 분해한 후에 모듈 내부 구현에 기능 분해를 적용할 수 있음
- 모듈은 `복잡성`, `변경 가능성`을 외부로부터 감춰야 함

###### 모듈의 장점과 한계

- 장점
  - 모듈 내부의 변수가 변경되더라도 내부에만 영향을 미침
  - 비즈니스 로직-UI를 분리할 수 있음
  - 전역 변수, 전역 함수를 제거해 네임 스페이스 오염을 방지
- 단점
  - 인스턴스의 개념을 제공하지 않음
    - 프로시저 추상화보다 높은 추상화 개념이지만 변경을 관리하기 위한 기법이라 추상화 관점에서 한계가 있음

----

##### 04. 데이터 추상화와 추상 데이터 타입

###### 추상 데이터 타입

- 타입: 변수에 저장할 수 있는 내용물의 종류와 연산의 가짓수를 정의함
- 추상 데이터 타입을 도입해 사용자가 정의하는 타입을 추가할 수 있게 됨
  - 객체를 생성할 수 있지만 데이터와 기능을 분리해서 바라봄
    - 데이터를 표현할 뿐, 기능을 구현하는 로직은 추상 데이터 타입의 외부에 존재함
  - 프로그래밍 언어의 관점에서는 내장 데이터 타입과 동일함

--

##### 05. 클래스

###### 클래스는 추상 데이터 타입인가?

- 클래스와 추상 데이터 타입을 동일한 것으로 설명하는 경우가 많지만 엄밀하게 같은 개념은 아님
  - 클래스: **상속**과 **다형성**을 지원함(객체지향 프로그래밍)
    - **절차를 추상화**:  내부에서 수행되는 절차는 다르지만 외부에는 감춤(다형성)
    - 타입을 기준으로 오퍼레이션을 묶음
  - 추상 데이터 타입: 상속X, 다형성X (객체 기반 프로그래밍)
    - 타입을 추상화한 것
    - 오퍼레이션을 기준으로 타입을 묶음

###### 변경을 기준으로 선택하라

- 클래스를 구현단위로 사용하기만 해서 객체지향 프로그래밍은 아님. **타입을 기준으로 절차를 추상화**해야만 객체지향 분해라고 할 수 있음
- 인스턴스 변수에 저장된 값을 기반으로 메서드 내에서 타입을 명시적으로 구분하는 방식은 추상 데이터 타입
- 객체 지향에서는 **조건문을 다형성으로 대체**함
  - 클라이언트가 적절한 메시지를 호출하는 것이 아니라 객체가 적절한 메시지를 선택

<br>

- 설계는 변경과 관계 있기 때문에 설계에 요구되는 변경이 '타입'인지 '오퍼레이션'인지에 따라 다르게 결정해야 함
  - 타입추가일 경우 객체지향
    - 추상 데이터 타입의 경우 새로운 타입을 추가하려면 타입을 확인하는 클라이언트 코드를 수정해야 함
  - 오퍼레이션 추가일 경우 추상 데이터 타입
    - 새로운 오퍼레이션을 추가하기 위해서 객체지향은 모든 클래스를 수정해야 함

###### 협력이 중요하다

- 객체지향에서 중요한 것은 역할, 책임, 협력이기 때문에 협력을 수행하기 위해 어떤 객체가 필요한지에 관해 고민하라