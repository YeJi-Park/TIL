### Object: OOP

#### Ch05. 책임 할당하기

- 데이터 중심의 설계로  인해 발생하는 문제는 데이터가 아닌 **책임**에 초점을 맞춰 해결할 수 있음
- **그런데 어떤 객체에게 어떤 책임을 할당할지는 어떻게 결정할 수 있을까?**
  - 책임 할당은 일종의 트레이드 오프이므로 동일한 문제에 다양한 접근이 있을 수 있음
  - 상황과 문맥에 따라 최선의 방법이 달라지기 때문에, **다양한 관점에서 설계를 평가할 수 있어야 함**

##### 01. 책임 주도 설계를 향해

데이터 중심→책임 중심으로 전환하기 위해서는 두가지 원칙을 지켜야 한다.

- 데이터보다 행동을 먼저 결정하라
- 협력이라는 문맥 안에서 책임을 결정하라

###### 데이터보다 행동을 먼저 결정하라

- 겍체에게 중요한 것은 데이터가 아니라 **외부에 제공하는 행동**
  - 데이터는 책임을 수행하는 데 필요한 재료일 뿐
  - 너무 이른 시기에 데이터에 초점을 맞추게 되면 캡슐화가 약화됨 → 변경에 취약해짐
- 객체를 설계하기 위해서 "이 객체가 수행해야 하는 책임은 무엇인가"를 먼저 질문하고 그 다음에 "이 책임을 수행하는 데 필요한 데이터는 무엇인가"를 결정해야 함

###### 협력이라는 문맥 안에서 책임을 결정하라

- 객체에 할당된 책임의 품질은 협력에 적합한 정도로 결정됨(협력에 어울리는 책임이어야 함)
- 협력을 시작하는 주체는 `메시지 전송자` 이므로 협력에 적합한 책임이란 수신자가 아니라 전송자에게 적합한 책임이어야 함
  - **메시지를 전송하는 클라이언트의 의도에 적합한 책임을 할당**
- **메시지를 결정한 후 그 메시지를 처리할 객체를 선택해야 함**
  - 객체가 아니라 메시지가 먼저 결정되기 때문에 송신자는 수신자에 대해 어떤 가정도 할 수 없음(캡슐화)

##### 02. 책임 할당을 위한 GRASP 패턴

- GRASP: General Responsibility Assignment Software Pattern 일반적인 책임 할당을 위한 소프트웨어 패턴

###### 도메인 개념에서 출발하기

- 설계를 시작하기 전에 도메인에 대한 개략적인 모습을 그려 어떤 책임을 할당 할 때의 후보로 사용할 수 있음
- 설계 단계에서는 도메인 개념이 정확하거나 완벽할 필요가 없음
  - 올바른 도메인 모델이란 존재하지 않으며 우리에게 필요한 것은 구현에 실용적으로 도움이 되는 모델!

###### 정보 전문가에게 책임을 할당하라

- 책임 주도 설계 방식의 첫 단계는 **애플리케이션이 제공해야 하는 기능을 애플리케이션의 책임으로 생각하는 것**
  1. 메시지를 전송할 객체는 무엇을 원하는가?
  2. 메시지를 수신할 적합한 객체는 누구인가?
     - Information Expert 패턴: 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당
     - **여기에서 이 정보를 알고 있다는 것은 정보를 '저장'하는 것과는 다른 개념**, 정보를 제공할 수 있는 다른 객체를 알거나, 필요한 정보를 계산해서 제공할 수 있음

###### 높은 응집도와 낮은 결합도

- 설계는 트레이드 오프이므로 동일한 기능을 구현할 수 있는 많은 설계 중에 한 가지를 선택하는 과정
- 책임을 할당할 수 있는 여러 대안들이 존재한다면 높은 응집도와 낮은 결합도를 얻을 수 있는 설계를 선택
  - 낮은 결합도 패턴: 설계의 전체적인 결합도가 낮게 유지되도록 책임을 할당
  - 높은 응집도 패턴: 높은 응집도를 유지할 수 있게 책임을 할당

###### 창조자에게 객체 생성 책임을 할당하라

- Creator(창조자) 패턴: 객체를 생성할 책임을 어떤 객체에게 할당할 지 결정하는 지침
  - B가 A 객체를 포함하거나 참조한다.
  - B가 A 객체를 기록한다.
  - B가 A 객체를 긴밀하게 사용한다.
  - B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다.
- 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에게 생성 책임을 맡겨서 추가적인 결합을 만들지 않도록 함

##### 03. 구현을 통한 검증

###### DiscountCondition 개선하기

- `DiscountCondition`이 변경될 수 있는 이유가 여러개이기 때문에 응집도가 낮음
  1. 새로운 할인 조건 추가
  2. 순번 조건을 판단하는 로직 변경
  3. 기간 조건을 판단하는 로직 변경
- 서로 다른 이유로 변경되는 로직은 분리되어야 함
- 코드를 통해 변경의 이유를 파악할 수 있는 방법
  1. 인스턴스 변수가 초기화되는 시점: 응집도가 높은 클래스는 모든 속성을 함께 초기화함
     - 함께 초기화되는 속성을 기준으로 코드를 분리할 수 있음
  2. 메서드들이 인스턴스 변수를 사용하는 방식: 메서드들이 사용하는 속성에 따라 그룹이 나뉘면 응집도가 낮음
     - 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 분리할 수 있음

###### 타입 분리하기

- 독립적인 여러 개의 타입이 하나의 클래스에 공존하기 때문에 이를 분리할 수 있음
  - 기간 조건
  - 순서 조건
- 이렇게 분리하면 `Movie`가 2개의 조건 클래스에 의존하게 되기 때문에 전체적인 결합도가 상승함

###### 다형성을 통해 분리하기

- `Movie`의 입장에서는 기간 조건과 순서 조건은 차이가 없고 할인 여부를 판단하는 동일한 책임을 수행함
  - 내부 구현은 `Movie`입장에서는 중요하지 않음
- 동일한 **역할**을 추상 클래스, 인터페이스를 사용해 다형성 패턴으로 분리할 수 있음

###### 변경으로부터 보호하기

- 새로운 할인 조건이 추가되더라도 `DiscountCondition`이라는 역할이 세부 구현을 감춤(캡슐화)

  - `Movie`에는 변경 없이 `DiscountCondition` 인터페이스를 실체화하는 클래스만 추가하면 됨

    → Protected Varation 변경 보호 패턴

###### 변경과 유연성

- 변경에 대비하는 방법은 크게 2가지가 있음
  - 수정하기 쉽도록 단순하게 설계
  - 수정하지 않고 변경을 수용할 수 있도록 유연한 코드를 만듦
- 상속 대신 합성을 사용해 유연한 코드를 만들 수 있음

##### 04. 책임 주도 설계의 대안

- 적절한 책임과 객체를 선택하는 게 어려울 때는 최대한 빠르게 목적한 기능을 수행하는 코드를 작성하고 이 책임들을 올바른 위치로 이동시키는 것도 좋은 방법
  - Refactoring: 겉으로 드러나는 동작이 바뀌어서는 안됨

###### 메서드 응집도

- 몬스터 메서드: 어떤 일을 수행하는 지 파악하기 어려운 긴 메서드
  - 응집도가 낮으므로 코드에 주석을 달아서 해석이 필요함
  - 메서드가 명령문들의 그룹으로 구성되어 있다면, 메서드를 작게 분해해서 응집도를 높여야 함

###### 객체를 자율적으로 만들자

- 객체를 자율적으로 만들기 위해서는 자신이 소유하는 데이터를 자기 스스로 처리하도록 만들어야 함

