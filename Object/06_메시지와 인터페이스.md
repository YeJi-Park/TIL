### Object: OOP

#### Ch06. 메시지와 인터페이스

- 애플리케이션이 클래스의 집합이라고 오해하기 쉬움
  - 하지만 클래스는 구현 도구일 뿐, 클래스가 아니라 객체와 객체가 수행하는 책임에 초점을 맞춰야 함
- 클래스 간의 정적인 관계가 아닌 **메시지 사이의 동적인 흐름**에 초점
- 객체가 수신하는 메시지들이 퍼블릭 인터페이스를 구성하므로 유연하고 재사용 가능한 인터페이스를 만들어야 함

##### 01. 협력과 메시지
###### 클라이언트-서버 모델
- 메시지를 매개로 하는 요청-응답의 조합이 협력을 구성함
- 클라이언트: 협력 안에서 메시지를 **전송**하는 객체
- 서버: 메시지를 **수신**하는 객체

![](https://github.com/YeJi-Park/TIL/blob/main/Object/images/06_1.PNG)
- `Screening` 클라이언트, 가격을 계산하라는 메시지를 전송
- `Movie` 서버, 가격 계산하는 서비스를 제공
- `Movie`가 최종 예매 요금을 계산하기 위해서는 다시  `DiscountPolicy`에게 할인 요금을 반환받아야 함
  - 여기에서 `Movie`는 클라이언트의 역할
  - **대부분의 객체는 클라이언트와 서버의 역할을 동시에 수행**함

<br>

- 협력의 관점에서 객체는 두 가지 종류의 메시지 집합으로 구성됨 
  1. 객체가 수신하는 메시지의 집합
  2. 외부의 객체에게 전송하는 메시지의 집합

###### 메시지와 메시지 전송
- 메시지: 객체들이 협력하기 위해 사용하는 의사소통 수단
  - 오퍼레이션 명, 인자로 구성됨
  - 메시지 전송/패싱: 한 객체가 다른 객체에 도움을 요청

###### 메시지와 메서드
- 메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 **수신자의 실제 타입**에 달려 있음
  - 메서드: 메시지를 수신했을 때 실제 수행되는 함수 또는 프로시저
  - 동일한 메시지를 전송하더라도, 수신 객체의 타입에 따라 실행되는 메서드는 다름

<br>

- 절차 지향적 코드에서는 코드의 의미가 컴파일 시점과 실행 시점에 동일함
- **객체 지향적 코드에서는 컴파일 시점과 실행 시점의 의미가 달라질 수 있음**
<br>

- 메시지와 메서드를 구분함으로써 전송지-수신자가 느슨하게 결합될 수 있게 함
  - 전송자는 어떤 메시지를 전송해야 하는지만 알면 됨
  - 수신자는 누가 전송했는지 알 필요가 없이, 메시지가 도착했다는 사실만 알면 됨
- **두 객체 사이의 결합도를 낮춤으로써 유연하고 확장 가능한 코드를 작성할 수 있음**

###### 퍼블릭 인터페이스와 오퍼레이션
- 외부에서는 객체가 공개하는 메시지**(퍼블릭 인터페이스)**를 통해서만 객체와 상호작용 할 수 있음
- 오퍼레이션: 퍼블릭 인터페이스에 포함된 메시지, 대부분 메시지의 시그니처를 가리킴

###### 시그니처
- 오퍼레이션의 이름과 파라미터 목록을 합쳐 시그니처라고 부름
- 오퍼레이션은 코드 없이 시그니처만을 정의한 것, 메서드는 이 시그니처에 구현을 더한 것

<br>

- 하나의 오퍼레이션에 대해 하나의 메서드만 존재할 경우 오퍼레이션/메서드를 구분할 필요가 없지만 다형성 관점에서 여러 메서드가 필요함
---

##### 02. 인터페이스와 설계 품질
좋은 인터페이스는 최소한의 인터페이스만 포함하면서 추상적이어야 한다.
→ 책임 주도 설계 방법을 따라 설계해야 함

###### 디미터 법칙
- 협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안됨
- **객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라!**
  - 자바에서는 오직 하나의 도트(.)만을 사용하라고도 요약됨
<br>

- 클래스가 특정한 조건을 만족하는 대상에게만 메시지를 전송해야 함
  - 조건
    -  클래스 내부의 메서드가 아래 조건을 만족하는 인스턴스에만 메시지를 전송하도록 해야 함
        -  this 객체
        -  메서드의 매개변수
        -  this의 속성
        -  this의 속성인 컬렉션의 요소
        -  메서드 내에서 생성된 지역 객체

- 디미터 법칙은 캡슐화를 위해 따라야 하는 구체적인 지침을 제공함
- 디미터 법칙을 따르는 코드는 내외부를 캡슐화하기 때문에 클라이언트-서버 사이에 낮은 결합도를 유지할 수 있음
<br>
```java
    screnning.getMovie().getDiscountCondition()
```
- 위 코드처럼 연쇄적으로 메시지를 전송하는 것을 **기차 충돌**이라고 부름
- 내부 구현이 외부로 노출됐을 때 나타나는 형태

```java
screnning.calculateFee(audienceCount);
```
- 디미터 법칙을 지키도록 개선
- 무비판적으로 디미터 법칙을 수용하면 객체의 응집도가 낮아질 수도 있음

###### 묻지 말고 시켜라
- 객체의 상태에 대해 묻지 말고 원하는 것을 시켜야 함
- **전송자는 수신자의 상태를 기반으로 결정을 내려서는 안됨**

###### 의도를 드러내는 인터페이스
- 메서드를 명명하는 방법
  1. 메서드가 작업을 어떻게 수행하는지 드러내도록 명명
    > isSatisfiedByPeriod, isSatisfiedBySequence 와 같은 방법
     - 내부 구현이 드러나기 때문에 좋지 못한 방법
      - 메서드를 이해해야만 어떤 작업을 수행하는 지 알 수 있음(가독성이 떨어짐)
      - 메서드 수준에서 캡슐화를 위반함
  2. 메서드가 무엇을 하는지 드러내도록 명명
   > isSatisfiedBy 로 추상화
    - 무엇을 하느냐에 초점을 맞춤
    - 클라이언트의 관점에서 동일한 작업을 수행하는 메서드를 하나의 타입 계층으로 묶을 수 있음

##### 03. 원칙의 함정
설계는 트레이드오프의 산물이며, 디미터 법칙과 묻지 말고 시켜라 스타일도 절대적인 법칙은 아님

- 원칙이 부적합하다고 판단되면 과감하게 무시해야 함
- **원칙을 아는 것보다 더 중요한 것은 언제 원칙이 유용하고 언제 유용하지 않은 지를 판단하는 것**

###### 디미터 법칙은 하나의 도트를 강제하는 규칙이 아니다

```java
IntStream.of(1,15,20,3,9).filter(x -> x > 10).distict().count();
```
- 위 코드는 IntStream이라는 동일한 클래스의 인스턴스를 반환하기 때문에 디미터 법칙을 위반하지 않음
- 디미터 법칙은 결합도와 관련된 것으로, 내부 구조가 외부로 노출될 경우에 문제가 됨
- **여러 개의 도트를 사용한 코드가 객체의 내부 구조를 노출하고 있는가?**

###### 결합도와 응집도의 충돌
- 모든 상황에서 맹목적으로 위임 메서드를 추가하면 객체가 상관없는 책임들을 갖게 될 수 있음
- 위 법칙들을 무작정 따르면 응집도가 낮아질 수 있음

##### 04. 명령-쿼리 분리 원칙
- 루틴: 어떤 절차를 묶어 호출할 수 있도록 이름을 부여한 기능 모듈
  -  프로시저: 부수효과를 발생시킬 수 있음, 반환값 없음, ≒ 명령
  -  함수: 부수효과 없음, 반환 값 있음, ≒ 쿼리
-  명령-쿼리 분리 원칙: 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안됨
   -  **질문이 답변을 수정해서는 안됨**

###### 반복 일정의 명령과 쿼리 분리하기
일정관리 프로그램을 통해 명령-쿼리 분리의 효용을 알아보자
<br>

- 이벤트: 특정 일자에 실제로 발생하는 사건 
- 반복 일정: 일주일 단위로 돌아오는 특정 시간 간격에 발생하는 사건들