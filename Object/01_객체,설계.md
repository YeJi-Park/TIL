### Object: OOP

#### Ch01. 객체, 설계

이론, 실무 중 어떤 것이 먼저일까? 
로버트 L. 글래스에 따르면 이론보다 실무가 먼저이다. 

	- 이론을 정립할 수 없는 초기에는 실무가 먼저 급속한 발전을 이룸
	- 실무가 발전한 후에야 실용성을 입증하기 위한 이론이 정립됨
	- 분야가 성숙해지는 시점에 이론이 실무를 추월하게 됨

어떤 분야든 아무 것도 없는 초기 단계에서 이론을 정립하기보다는 **실무를 관찰한 결과를 바탕으로 이론을 정립하는 것**이 최선이다. 
소프트웨어는 다른 공학에 비해 아직 걸음마 단계이기 때문에 **이론보다는 실무가 앞선 단계**이다.

- '**설계**'와 '**유지보수**'가 대표적으로 실무가 앞서있는 분야

  > 설계 원칙과 개념 등은 이론에서 출발했다기보다는 실무에서 반복적으로 적용되던 기법을 이론화 한 것

**"코드"가 가장 개발자인 우리가 잘 이해할 수 있는 매체이기에, 코드를 이용해 객체지향을 설명할 것**

-----

##### 01. 티켓 판매 애플리케이션 구현하기

소극장에서 공연을 보러 온 관객을 입장시킬 때, 아래 2가지 경우가 있다.

- 초대장을 가진 관람객은 초대장을 티켓으로 교환 후 입장할 수 있음
- 초대장이 없는 관람객은 티켓을 판매한 후에 입장시켜야 함

**티켓 판매 시나리오를 정리한 전체 어플리케이션 구조**

![](https://github.com/YeJi-Park/TIL/blob/main/Object/images/01_1.1.PNG)

##### 02. 무엇이 문제인가

_<클린 소프트웨어: 애자일 원칙과 패턴, 그리고 실천 방법>_에 따르면 소프트 웨어 모듈은 3가지 기능을 가져야 한다.

1. 실행 중에 제대로 동작할 것
2. 변경이 용이할 것
3. 코드를 읽는 사람이 이해하기 쉬울 것

위 코드는 동작에 이상은 없지만, 2번과 3번을 만족시키지 못한다.

###### 예상을 빗나가는 코드: 3번

1. 실제 현실과 매핑되지 않는 코드
   현재의 구조대로라면 `Theater` 클래스가 관람객의 가방을 열어서 초대장을 가져가고, 매표소의 티켓과 현금에 마음대로 접근한다. 
   실제를 생각해본다면, 관람객이 직접 가방에서 초대장을 꺼내 판매원에게 건네고 판매원이 이를 처리하는 것이 상식적이다.
2. 코드 이해를 위해 너무 세부적인 내용을 알아야 함
   `Theater`의 enter를 이해하기 위해서는 `TicketSeller`, `TicketOffice`, `Audience`, `Bag` 등의 너무 많은 세부 사항을 이해하고 있어야 한다.

###### 변경에 취약한 코드: 2번

현재의 요구사항은 만족하지만 만약 요구사항이 추가된다면?

- 관람객이 가방을 들고 있지 않은 경우

  - `Audience`에서 `Bag`을 제거하고 이에 접근하는 `Theater`의 enter 메소드도 수정되어야 함

    → `Theater`가 지나치게 세부적인 사실에 의존하고 있음

**애플리케이션의 기능을 구현하는 데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거해야 한다.**

##### 03. 설계 개선하기

위 2가지 문제는 `Theater`가 `Audience`와 `TicketSeller`에 대해 너무 자세히 알지 못하도록 정보를 차단하면 해결된다.
**`Theater`가 원하는 것은 관람객이 소극장에 입장하는 것 뿐이다.** 

→ **관람객과 판매원을 자율적인 존재로 만들어 세부적인 내용은 각 객체 스스로 처리하도록 변경한다.**

###### 자율성을 높이자

설계를 변경하기 어려운 이유는 `Theater`가 `TicketSeller`, `TicketOffice`, `Audience`, `Bag` 전체에 마음대로 접근할 수 있기 때문이다.
`TicketSeller`와 `Audience`가 `TicketOffice` ,`Bag` 를 직접 처리하는 **자율적인 존재**가 되도록 설계를 변경하자

1. TicketSeller

   -  `Theater`의 enter 메서드에서 `TicketOffice`에 접근하는 모든 코드를 `TicketSeller`의 sellTo로 옮김
     → `Theater`는 `TicketSeller`에게 메시지를 보내기만 할 뿐 (인터페이스에만 의존) `TicketOffice`와 관련된 세부적인 동작 (구현의 영역)을 알 필요가 없음

   - `TicketOffice`는 더 이상 외부에서 접근할 수 없게 private 로 변경

   - `TicketSeller`는 `TicketOffice`에 직접 접근해서 티켓을 꺼내고 판매금액을 적립

     → **캡슐화**를 통해 객체 내부의 세부적인 사항을 감추고 객체 사이의 결합도를 낮춤

![](https://github.com/YeJi-Park/TIL/blob/main/Object/images/01_1.2.PNG)

- `Theater`에서 `TicketOffice`로의 의존성이 제거됨

2. Audience

   - `TicketSeller`와 동일하게 `Bag`에 접근하는 모든 로직을 `Audience` 내부로 숨김

   ![](https://github.com/YeJi-Park/TIL/blob/main/Object/images/01_1.3.PNG)

###### 무엇이 개선됐는가

- 의사소통(2번)
  - `Audience`, `TicketSeller`가 직접 소지품을 관리하기 때문에 코드를 읽는 사람의 예상에서 벗어나지 않음
- 변경용이성(3번)
  - `Audience`, `TicketSeller`가 변경되더라도 `Theater`는 변경될 필요가 없음

###### 어떻게 한 것인가

`Audience`, `TicketSeller`의 자율성을 높임으로써 `Theater`가 갖고 있던 `Audience`, `TicketSeller`와의 결합도를 낮춤

###### 캡슐화와 응집도

- 핵심은 **객체 내부의 상태를 캡슐화하고 객체 간에 메시지를 통해서만 상호작용하도록 만드는 것**
- 자신과 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체는 **응집도**가 높음
  - 자신의 데이터를 스스로 처리하도록 해 결합도를 낮추고 응집도를 높여야 함

###### 절차지향과 객체지향

- 절차지향
  - 초기 설계처럼 모든 처리를 `Theater` **프로세스** 가 하고 나머지 클래스들은 **데이터**의 역할만 수행하는 전형적인 절차적 프로그래밍 방식
  - `Theater`가 `TicketSeller`, `TicketOffice`, `Audience`, `Bag` 모두에 의존하고 있기 때문에 변경이 어려움
- 객체지향
  - 데이터를 사용하는 프로세스가 데이터를 소유하고 있는 `Audience`, `TicketSeller`로 옮겨짐
  - 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍

###### 책임의 이동

- 두 방식 사이에 근본적인 차이는 **책임의 이동**

- 절차지향: 책임이 `Theater`에 집중되어 있음

  ![](https://github.com/YeJi-Park/TIL/blob/main/Object/images/01_1.4.PNG)

- 객체지향: **제어 흐름이 각 객체에 분산**

  ![](https://github.com/YeJi-Park/TIL/blob/main/Object/images/01_1.5.PNG)

  	- **적절한 객체에 적절한 책임을 할당**
  	- 어떤 데이터를 가지느냐가 아니라 어떤 책임을 할당할 것인가에 초점을 맞출 것

###### 더 개선할 수 있다

- Bag
  - `Audience`에 의해 끌려다니는 수동적인 존재임
  - `Bag`의 내부 상태에 접근하는 모든 로직을 캡슐화해서 결합도를 낮출 수 있음
- TicketOffice
  - `TicketSeller`가 `TicketOffice`의 내부에 직접 접근해 `Audience`에게 전달함
  - 반면 `TicketOffice`와 `Audience` 사이의 의존성이 추가됨 → 결합도가 상승

위 경우에서 보듯이 설계는 균형이 중요하며, 적절한 트레이드오프 과정을 거쳐야 한다.

###### 그래, 거짓말이다!

실제 세상에서 `Theater`, `Bag`, `TicketOffice`는 자율적인 존재가 아니지만 객체지향에선 자율적인 존재로 의인화하여 설계한다.
훌륭한 객체지향 설계란 **소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하는 설계**이다.

##### 4. 객체지향 설계

설계는 구현과 떨어트려 생각할 수 없으며 코드 작성의 일부이다.
변경 전과 변경 후는 동일한 결과지만 두 프로그램은 완전히 다른 설계를 가진 것이다.

좋은 설계란 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계이다. 
변경을 수용할 수 있는 설계가 중요한 이유는 요구사항은 항상 변경되고, 개발 시작 시점에 모든 요구사항을 수집하는 건 불가능함
또한, 코드를 변경할 때 버그가 추가될 가능성이 높기 때문에 코드 수정을 줄일 수록 좋음 

###### 객체지향 설계

- **변경에 유연하게 대응할 수 있는 코드**가 필요함

  - 객체지향은 의존성을 효율적으로 통제할 수 있는 방법을 제시함으로써 요구사항 변경에 유연하게 대응할 수 있음
  - 세상을 바라보는 방식 대로 코드를 작성할 수 있게 도움

- 데이터/프로세스를 객체로 만든다고 해서 변경이 쉬운 코드가 되는 것은 아님 

  - 객체 사이의 상호작용은 메시지로 이루어지고 이 협력 과정 사이에서 다른 객체에 의존하게 됨
  - **객체 사이의 의존성을 적절하게 관리하는 것이 중요함**

  

