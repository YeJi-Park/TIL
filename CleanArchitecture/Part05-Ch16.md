### Clean Architecture

#### 05부 아키텍처

#### 16장. 독립성

##### 유스케이스

시스템의 아키텍처는 시스템의 의도를 지원해야 함
아키텍트의 최우선 관심사는 유스케이스이며, 아키텍처에서도 유스케이스가 최우선이 되어야 함

좋은 아키텍처는 **행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만듦**
잘 만들어진 시스템의 유스케이스는 시스템 구조 자체에서 한눈에 드러나며, 행위가 일급 요소로 정의되어 시스템의 최상위 수준에서 알아볼 수 있으므로 개발자가 별도로 찾을 필요가 없음

----

##### 운영

시스템의 운영 지원 관점에서 아키텍처는 시스템의 요구와 관련된 유스케이스에 걸맞은 처리량과 응답시간을 보장해야 함

시스템 별로 요구하는 형태가 다르지만, 운영에 필요한 요구사항이 바뀌더라도 전환할 수 있도록 아키텍처를 구성해야 함

----

##### 개발

아키텍처는 개발환경을 지원하는 데에 핵심적인 역할을 수행함

- 콘웨이의 법칙: 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어낼 것이다.

많은 팀으로 구성되며, 관심사가 다양한 조직에서는 각 팀이 독립적으로 행동하기 편한 아키텍처를 확보하여 서로를 방해하지 않을 수 있게 해야 함

---

##### 배포

좋은 아키텍처는 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 함
이러한 아키텍처를 만들려면, 시스템을 컴포넌트 단위로 적절하게 분할하고 격리시켜야 함

마스터 컴포넌트를 통해 시스템 전체를 하나로 묶고 각 컴포넌트를 올바르게 구동하고 통합하고 관리할 수 있어야 함

---

##### 선택사항 열어놓기

좋은 아키텍처는 위의 관심사들 사이에 균형을 맞추고 모두 만족시켜야 하지만, 현실적으로 이러한 균형을 잡기가 어려움
대부분의 경우 모든 요구사항과 유스케이스들을 알 수 없으며 알고 있다고 하더라도 이 사항들이 변화함
→ 선택사항을 열어둠으로써 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 해야 함

---

##### 결합 분리

- **계층 결합 분리**

  아키텍트는 필요한 모든 유스케이스를 지원할 수 있는 시스템 구조를 원하지만 유스케이스 전부를 알지는 못함
  하지만 시스템의 기본적인 의도는 알고 있기 때문에 그 의도의 맥락에 따라 컴포넌트를 묶고 분리할 수 있음

  에를 들어 UI와 업무 규칙은 서로 다른 이유로 변경되기 때문에 둘은 분리되어야 함
  **시스템을 결합되지 않는 수평적인 계층으로 분리해야 함**

- **유스케이스 결합 분리**

  주문 삭제와 주문 추가의 유스케이스는 다른 이유로 변경될 것이기 때문에 시스템을 분할하는 자연스러운 방법임

  유스케이스는 시스템을 수직적으로 가로지르기 때문에 서로 다른 유스케이스의 UI/업무규칙 등의 각 계층에서 겹치지 않도록 분리해야 함
  이렇게 유스케이스의 결합을 분리하면 기존 요소에 지장을 주지 않고도 새로운 유스케이스를 추가할 수 있게 됨

---

#####  독립성

- 개발 독립성

  컴포넌트가 분리되면 서로 다른 컴포넌트를 개발하는 팀은 서로의 컴포넌트에 영향을 주기 힘듦
  계층과 유스케이스의 결합이 분리되어 있으면 시스템의 아키텍처는 팀 구조를 뒷받침해줄 수 있음

- 배포 독립성

  결합이 분리되면 배포 측면에서도 유연해져 Hot-swap이 가능해짐

----

##### 중복

소프트웨어에서 중복은 일반적으로 나쁜 것이지만, 진짜 중복과 우발적 중복을 분리해야 함
현재는 중복된 코드이지만 두 코드가 다른 이유로 변경되고 발전한다면 이는 우발적 중복이기 때문에 통합하면 나중에 다시 분리해야 함
**진짜 중복인지 확인이 필요함**

---

**결합 분리 모드**

유스케이스를 분리하는 것은 운영에도 도움이 되지만 운영 측면에서 이점을 살리기 위해선 결합을 분리할 때 적절한 모드를 선택해야 함

계층과 유스케이스의 결합은 여러 수준에서 가능함

- 소스 수준 분리: 소스 코드 모듈 사이의 의존성을 제어
  하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일하지 않도록 만들 수 있음
  모든 컴포넌트가 같은 주소 공간에서 실행되고 메모리에 하나의 파일이 올라감(모노리틱/단일체 구조)
- 배포 수준 분리: jar, DLL 등 배포 가능한 단위들 사이의 의존성을 제어
  한 모듈이 변하더라도 다른 모듈을 재빌드하거나 재배포하지 않도록 만들 수 있음
- 서비스 수준 분리: 의존하는 수준을 데이터 구조 단위로 낮추고 네트워크를 통해서만 통신
  모든 실행 가능한 단위는 소스-바이너리 변경에 대해 독립적임

프로젝트 초기에는 어떤 모드가 최선인지 알기 어렵고 프로젝트가 성숙해갈수록 최적인 모드가 달라짐

좋은 아키텍처는 시스템이 모노리틱 구조로 태어나서 단일 파일로 배포되더라도 이후에는 독립적으로 배포 가능한 단위들의 집합으로 성장하고, 독립적인 서비스 단위로  성장할 수 있도록 만들어져야 함
또한 상황이 바뀌었을 때 진행 방향을 거꾸로 돌려 원래 형태로도 돌릴 수 있어야 함 

**좋은 아키텍처는 결합 분리 모드를 선택 사항으로 남겨서 배포 규모에 따라 가장 적합한 모드를 선택해 사용할 수 있어야 함**