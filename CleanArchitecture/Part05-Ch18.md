### Clean Architecture

#### 05부 아키텍처

#### 18장. 경계 해부학

시스템 아키텍처는 일련의 소프트웨어 컴포넌트와 그 컴포넌트를 분리하는 경계에 의해 정의됨
경계는 변경이 전파되는 것을 막는 방화벽을 구축하고 관리하는 수단으로써 존재

---

##### 단일체

가장 단순하며 흔한 형태로, **물리적으로 엄격하게 구분되지 않는 형태**
함수와 데이터가 단일 프로세서에서 같은 주소 공간을 공유하며 나름의 규칙에 따라 분리되어 있음(소스 수준 분리 모드)

배포 관점에서는 **단일체**라고 불리는 단일 실행 파일
컴포넌트 수준으로 분리되지 않으므로 배포 기준으로는 단일 파일이 배포되므로 경계가 드러나지 않음

하지만 최종적으로는 단일 실행 파일이 되더라도, 컴포넌트를 분리하고 바이너리로 만드는 과정을 독립적으로 수행하게 하는 과정은 가치 있는 것

대부분의 경우에 동적 다형성에 의존하여 내부 의존성을 관리함

가장 단순한 형태의 제어흐름은 저수준 클라이언트가 고수준 서비스의 함수 호출
(런타임 의존성, 컴파일타임 의존성 모두가 저수준→고수준으로 향함)

고수준 클라이언트가 저수준 서비스를 호출해야 한다면, 동적 다형성을 사용하여 제어흐름과는 반대 방향으로 의존성을 역전시킬 수 있음
고수준 클라이언트가 인터페이스를 통해 저수준 서비스의 함수를 호출
(컴파일 타임: 저수준→고수준 / 런타임: 고수준→저수준)

정적 링크된 단일체 구조의 실행 파일이라도 이런 방식으로 구조를 분리하면 컴포넌트를 독립적으로 유지할 수 있기 때문에 개발 및 배포 과정에 도움이 됨

경계를 가로지르는 통신은 함수 호출의 형태이므로 빠르고 값싸게 가능하므로 빈번하게 이루어짐

---

##### 배포형 컴포넌트

경계가 물리적으로 드러나는 형태로, 동적 링크 라이브러리가 가장 단순한 예시
(배포 수준 결합 분리 모드)

배포 과정에서 차이가 날 뿐, 단일체와 동일하며 컴포넌트간 의존성을 관리하는 전략도 단일체와 동일함
통신 또한 함수 호출의 형태이므로 최초에는 링크에 시간이 걸리지만 빈번하게 이루어짐

----

##### 로컬 프로세스

훨씬 강한 물리적 형태를 띠는 아키텍처 경계

로컬 프로세스 간 분리 전략은 단일체나 ㅂ바이너리 컴포넌트와 동일하며 고수준 컴포넌트를 향함
따라서 로컬 프로세스에서는 고수준 프로세스의 소스 코드가 저수준 프로세스의 정보를 포함해서는 안됨
저수준 프로세스가 고수준 프로세스의 플러그인이 되도록 만드는 것이 아키텍처 관점의 목표 

---

##### 서비스

물리적 위치에 구애받지 않는 서로 다른 프로세스로 분리
서비스들은 모든 통신이 네트워크를 통해 이뤄진다고 가정

서비스 경계를 지나는 통신은 함수 호출에 비해 느리므로 지연에 따른 문제를 고수준에서 처리할 수 있어야 함
고수준 서비스의 소스 코드에서는 저수준 서비스를 특정 짓는 어떤 물리적인 정보도 포함해서는 안됨
저수준 서비스는 반드시 고수준 서비스에 플러그인 되어야 함

