### Clean Architecture

#### 03부 설계 원칙

##### SOLID 원칙

- SOLID 원칙은 **함수와 데이터 구조를 클래스로 배치하는 방법, 이 클래스들을 결합하는 방법을 설명함**
- **모듈 수준**의 SW구조에 SOLID 원칙을 적용하는 목적
  → 모듈이 잘 설계되더라도, 완성된 시스템이나 아키텍처가 엉망일 가능성도 존재함
  - 변경에 유연
  - 이해하기 쉬움
  - 많은 SW 시스템에 사용될 수 있는 컴포넌트의 기반
- 아래에서는 SOLID 원칙 자체가 아니라, **SOLID 원칙이 아키텍처 관점에서 지닌 의미에 대해 논의**

-----

##### 7장. SRP: 단일 책임 원칙

- 단일 모듈은 오직 하나의 *액터*에 대해서만 책임져야 한다.

  > 액터: 시스템이 변경되기를 원하는 한 명 이상의 집단

- 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 응집성(Cohesion)

###### SRP를 위반하는 예시

- 우발적 중복: 한 개의 클래스가 여러 액터를 책임져, 한 액터를 위한 수정이 다른 액터에도 영향을 미침
- 병합: 서로 다른 액터를 위한 변경이 동시에 이루어질 경우 병합에 충돌이 발생할 수 있음
- 해결책
  1. 데이터와 메서드를 분리
     - 각 클래스에 자신의 메서드에 필요한 코드만을 포함시켜 중복을 피할 수 있음
     - 개발자가 각 클래스들을 인스턴스화하고 추적해야 하는 문제가 있음
  2. 파사드 패턴
     - Facade 클래스를 만들어 분리된 클래스들의 객체를 생성하고 요청된 메서드를 위임하는 일을 책임지게 함
  3. 중요한 업무 규칙을 데이터와 가깝게 배치
     - 2와 비슷하지만 중요한 메서드는 기존의 클래스에 유지하고, 이 클래스를 덜 중요한 나머지 메서드들에 대한 Facade로 이용

###### 결론

- **단일 책임 원칙은 메서드와 클래스 수준의 원칙**이지만 상위의 수준에서도 비슷한 개념이 존재함

---

##### 8장. OCP: 개방-폐쇄 원칙

- 소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.

  → 개체의 행위는 확장할 수 있어야 하지만, 이 때 개체를 변경해서는 안됨

- 어떤 기능이 바뀌어야 할 때 **변경되는 코드의 양이 최소화** 되어야 함

  → 다른 목적으로 변경되는 요소를 적절하게 분리(SRP), 요소 간의 의존성을 체계화(DIP)해 변경량을 최소화할 수 있음

- SRP를 적용해 책임을 분리하고 두 책임 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록 의존성도 조직화해야 함

- 이를 위해서는 처리 과정을 클래스 단위로 분할하고 클래스를 컴포넌트 단위로 구분해야 함

- 아키텍트는 기능이 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고 분리한 기능을 계층 구조로 조직화함

  → 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있음

------

##### 9장. LSP: 리스코프 치환 원칙

- S 타입의 객체 o1 각각에 대응하는 T타입 객체 o2가 있고 T 타입을 이용해 정의한 프로그램 P에서 o2의 자리에 o1를 치환해도 P의 행위가 변하지 않는다면 S는 T의 하위 타입이다.

###### LSP 위반하는 예시1: 정사각형/직사각형 문제

- 정사각형을 직사각형의 하위 타입으로 설계한다면, 직사각형의 높이/너비는 독립적이지만 정사각형의 높이/너비는 의존적이기 때문에 문제가 생김
- LSP 위반을 막기 위해 정사각형임을 검사할 수 있지만, 이렇게 하면 행위가 세부 타입에 의존적이므로 타입 치환할 수 없게 됨

###### LSP 위반하는 예시2: 택시 서비스 어플리케이션

- 여러 택시 파견 서비스를 통합하는 애플리케이션을 만든다고 할 때, 다양한 택시 업체가 동일한 인터페이스를 준수하도록 만들어야 함
- 위 사항이 지켜지지 않으면, 이 예외 사항을 처리하는 로직을 추가해야 하고 분석하기 어려운 에러가 발생할 여지가 생기게 됨

###### 결론

- **LSP는 아키텍처 수준까지 확장 해야 함.** 치환 가능성을 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있음

---

##### 10장. ISP: 인터페이스 분리 원칙

- 다수의 사용자가 한 클래스 내의 서로 다른 Operation을 사용한다고 가정할 때, OP2이 변경되면 User1, User3도 재컴파일 후 배포가 필요함
  (OP1, OP3이 같은 클래스에 있어 의존하고 있기 때문에)

- 동적 타입 언어에서는 런타임에 타입 추론이 발생하기 때문에 위와 같은 소스 코드 의존성이 발생하지 않아 언어의 문제라고 생각하기 쉬움

  → 아키텍처 수준에서도 특정 시스템에 의존성이 생길 수 있기 대문에 고수준의 시스템에서도 ISP를 고려해야 함

----

##### 11장. DIP: 의존성 역전 원칙

- 소스  코드 의존성이 추상에 의존하며 구체에는 의존하지 않아야 한다
  - 실제로는 모든 구체적인 클래스, 플랫폼 등에 대해서 의존하지 않을 수 없기 때문에 안정성이 보장된 환경에 대해서는 무시하는 편
  - **변동성이 큰 구체적인 요소에 대해 의존하지 않아야 함**

###### 안정된 추상화

- 변동성이 큰 구체 클래스를 참조하지 말라
  - 구체 클래스가 아닌 추상 인터페이스를 참조해야 함
  - 추상 팩토리를 사용
- 변동성이 큰 구체 클래스로부터 파생하지 말라
  - 상속은 코드에 존재하는 모든 관계 중 가장 강력하고 뻣뻣한 관계이기 때문에 변경하기 어려움
- 구체 함수를 오버라이드 하지 말라
  - 구체 함수는 대부분 소스 코드 의존성을 필요로 하고 이 구체 함수를 오버라이드 하면 의존성도 상속하게 됨
  - 추상 함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현해야 함
- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라

###### 팩토리

- 변동성이 큰 구체적인 객체는 특별히 주의해서 생성해야 함
- 제어 흐름은 소스 코드 의존성과는 반대 방향으로 역전되기 때문에 의존성 역전 원칙이라 부름

###### 구체 컴포넌트

- 모든 DIP 위배를 없앨 수는 없지만, DIP를 위배하는 클래스를 적은 수의 구체 컴포넌트 내부로 모아서 나머지 부분과 분리할 수 있음

