### Clean Architecture

#### 04부 컴포넌트 원칙

SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법에 관한 것

----

#### 12장. 컴포넌트

##### 컴포넌트란?

시스템의 구성 요소로 배포할 수 있는 가장 작은 단위

> 자바: jar, 루비: gem, 닷넷: DLL

- 컴파일형 언어: 바이너리 파일의 결합체
- 인터프리터형 언어: 소스 파일의 결합체

여러 컴포넌트를 링크하여 실행 가능한 단일 파일로 생성할 수 있고 여러 컴포넌트를 묶어 단일 아카이브(ex. war)나 동적 플러그인(.jar, .dll), 단독 어플리케이션(.exe) 등의 형태로 배포할 수도 있음

컴포넌트가 어떤 형태로 배포되든 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한 형태여야 함

##### 컴포넌트의 간략한 역사

###### 초창기: 고정된 메모리 위치

메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 직접 제어했고 한번 위치가 결정되면 재배치가 불가능
(시작부에 로드될 주소를 프로그래머가 직접 선언)

라이브러리 함수의 코드를 애플리케이션 코드에 직접 포함시켜 단일 프로그램으로 컴파일해서 사용
(소스 코드의 형태로 유지)

메모리가 작아 코드 전체를 메모리에 올릴 수 없었기 때문에, 여러 차례 읽어야 하기 때문에 속도가 매우 느렸음

이를 해결하기 위해 라이브러리와 어플리케이션을 분리해서 컴파일하는 방법을 사용했으나, 어플리케이션이 커짐에 따라 할당된 메모리가 부족해지는 현상이 발생

###### 재배치성: 링킹 로더

컴파일러가 코드에 메모리의 시작 주소를 알려주는 플래그를 삽입하고 로더는 재배치 코드가 자리할 위치 정보를 전달받음
→ 재배치가 가능한 바이너리를 만들어 필요한 함수만을 로드할 수 있게 됨

라이브러리 함수를 호출하는 프로그램이라면 컴파일러가 함수 이름을 외부 참조로 생성하고, 라이브러리 함수를 정의하는 프로그램이면 외부 정의로 생성해 로드할 위치가 정해지면, 로더가 외부 참조를 외부 정의에 링크시킬 수 있게 됨

###### 링커

프로그램이 커져서 링킹 로더가 느려짐에 따라 로드/링크가 분리됨

- 링커: 링크가 완료된 재배치 코드를 만듦
- 로더: 링킹된 코드를 재배치하고 메모리에 로드함

링킹 시간은 여전히 오래 걸리지만 한 번 실행 파일을 만들면 빠르게 로드할 수 있기 때문에 빨리 실행할 수 있음

컴퓨터의 메모리가 빠르게 증가해 링킹 시간이 줄어들고 로드와 링크를 동시에 할 수 있게 되고 다수의 공유 라이브러리를 링크한 후, 링크된 프로그램을 실행할 수 있게 됨
→ **컴포넌트 플러그인 아키텍처**

------

#### 13장. 컴포넌트 응집도

어떤 클래스를 어떤 컴포넌트에 포함시켜야 할 지에 대한 3가지 원칙

##### REP: 재사용/릴리스 등가 원칙

> **재사용 단위는 릴리스 단위와 같다.**

소프트웨어 컴포넌트가 릴리스 절차를 통해 추적/관리되지 않거나 번호가 부여되지 않는다면 해당 컴포넌트를 재사용하고 싶어도 할 수 없음

새로운 릴리스가 나오면 새 릴리즈의 변경 사항을 살펴보고 새 릴리스를 통합할지, 한다면 언제 할 지 결정해야 함

이 원칙을 소프트웨어 설계와  아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함을 뜻함
→ **컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 함**

하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스되고 추적/관리 되어야 하며 동일한 릴리스 문서에 포함되어야 함

이 원칙만으로는 클래스와 모듈을 단일 컴포넌트로 묶는 방법을 제대로 설명하기 힘들지만 이 원칙을 어기면 '이치에 맞지' 않기 때문에 쉽게 발견됨

다음에 나올 CCP, CRP는 REP를 보완하고 제약을 가하는 측면에서 정의함

##### CCP: 공통 폐쇄 원칙

> **동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 서로 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.**

**CCP는 SRP를 컴포넌트 관점에서 다시 쓴 것**. 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안됨

대다수의 어플리케이션에서 유지보수성은 재사용성보다 훨씬 중요함
→ 변경을 단일 컴포넌트 안에서만 발생하도록 제한할 수 있다면 해당 컴포넌트만 재배포하면 되고 의존성이 없는 다른 컴포넌트는 검증이나 재배포할 필요가 없음

CCP는 같은 이유로 변경될 가능성이 있는 클래스는 한 곳으로 묶을 것을 권함
**물리적/개념적으로 결합되어 함께 변경되는 클래스는 한 컴포넌트에 속하게 해 소프트웨어 릴리즈/재검증 배포 관련된 작업량을 최소화할 수 있음**

CCP는 OCP와도 밀접한 관련이 있음(CCP의 폐쇄Closure는 OCP의 폐쇄와 동일한 의미)
100% 완전한 폐쇄는 불가능하므로 전략적으로 폐쇄해야 함 → 발생할 가능성이 있거나 과거에 발생했던 공통적인 변경에 대해 클래스가 닫혀있도록 설계해야 함
동일한 유형의 변경에 대해 닫혀있는 클래스들을 하나의 컴포넌트로 묶음으로써 변경이 영향을 주는 컴포넌트들이 최소한으로 한정될 수 있음

##### CRP: 공통 재사용 원칙

> **컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 마라.**

같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 함 
개별 클래스가 단독으로 재사용되는 경우는 거의 없고, 재사용 모듈의 일부로써 모듈 내의 다른 클래스들과 상호작용하는 경우가 많음
이러한 클래스들 사이에는 수많은 의존성이 있음

> ex) 컨테이너 클래스↔이터레이터 클래스
> 서로 강하게 결합되어 있기 때문에 함께 재사용되고 이들은 동일한 컴포넌트에 위치해야 함

CRP는 **동일한 컴포넌트에 묶어선 안되는 클래스가 무엇인지**도 말해줌
어떤 컴포넌트가 다른 컴포넌트를 사용하면 두 컴포넌트 사이에는 의존성이 생겨나고 이 의존성으로 인해 사용되는 컴포넌트가 변경될 때마다 사용하는 컴포넌트도 변경해야 할 가능성이 높음
발생한 변경이 사용하는 컴포넌트와는 전혀 관련 없는 경우라도 변경될 수 있음

의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함 
→ 한 컴포넌트에 속한 클래스들은 더 작게 그룹지을 수 없으며, 일부에만 의존하고 나머지에는 독립적일 수 없음

어떤 클래스를 묶어야하는 지 보다는 어떤 클래스를 함께 묶어서는 안되는지에 대해 더 집중해야 함
**강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안됨**

CRP는 ISP의 포괄적인 버전으로, "필요하지 않는 것에 의존하지 말라"로 요약할 수 있음

##### 컴포넌트 응집도에 대한 균형 다이어그램

REP, CP는 포함 원칙이므로 컴포넌트를 크게 만들고, CRP는 배제 원칙이기 때문에 컴포넌트를 더 작게 만듦
이 원칙들 간에 균형을 이루는 방법을 찾아야 함

![Clean Architecture: 컴포넌트 원칙](https://blog.kakaocdn.net/dn/kR7yf/btqJRkNOat8/eeEiwitz7pMVsOk83AEHGK/img.jpg)

다이어그램의 각 변은 반대쪽 꼭지점에 있는 원칙을 포기했을 때 감수해야 할 비용을 나타냄

- REP, CRP에만 집중하면 사소한 변경이 생겼을 때 너무 많은 컴포넌트에 영향을 미침
- CCP, REP에만 집중하면 불필요한 릴리스가 너무 빈번해짐

아키텍트는 이 사이에서 현재 개발팀의 니즈를 충족시키는 위치를 찾아야 하며, 프로젝트의 시간과 성숙도에 따라 이 니즈가 변경된다는 것도 이해하고 있어야 함
예를 들어, 프로젝트 초기에는 재사용성보다 개발가능성이 더 중요하므로 CCP가 REP보다 더 중요함

##### 결론

어느 클래스를 묶어서 컴포넌트로 만들지를 결정할 때, 재사용성과 개발가능성이라는 상충하는 힘을 고려해야 함
이 균형점은 유동적이기 때문에 컴포넌트의 구성 방식도 변경되고 진화할 수 있음

---

#### 14장. 컴포넌트 결합

개발 가능성-논리적 설계 사이의 균형과 컴포넌트 사이의 관계를 설명하는 원칙 

##### ADP: 의존성 비순환 원칙

> **컴포넌트 의존성 그래프에 순환이 있어서는 안된다.**

많은 개발자가 동일한 소스 파일을 수정하는 환경에서 다른 개발자가 의존성을 수정하면서 동작이 되지 않는 문제가 생김
프로젝트와 개발팀 규모가 커지면서 이 문제는 점점 더 해결하기 어려워짐

###### 해결책1: 주 단위 빌드(Weekly build)

첫 4일 동안은 통합을 고려하지 않고 개인적으로 작업하고 금요일이 되면 통합하여 빌드를 함

- 장점: 5일 중 4일 동안 개별적으로 개발할 수 있음
- 단점: 프로젝트가 커지면 통합 작업에 수반되는 시간이 길어져 효율성이 나빠짐

###### 해결책2: 순환 의존성 제거하기

개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것

컴포넌트를 개별 개발자/단일 팀이 책임질 수 있는 단위로 분리하고 해당 컴포넌트가 동작하는지 확인해 이 컴포넌트를 릴리스함
개발자는 개인 공간에서 컴포넌트를 수정하고 다른 개발자들은 릴리스된 버전을 사용해 특정 컴포넌트가 변경되더라도 즉각 영향을 받지 않음

통합이 작고 점진적으로 이루어져 한 시점에 모든 개발자가 모여서 통합해야 할 필요가 없음
단순하고 합리적이어서 많이 사용됨

→ 이 방법이 사용되려면 **의존성 구조에 순환이 있어서는 안됨**

###### 컴포넌트 의존성

![Jeremy&#39;s Blog | 클린 아키텍처(Clean Architecture) 1](https://sungjk.github.io/images/2019/10/26/14_1.png)

위 그래프는 순환이 없는 비순환 방향 그래프임

의존성 화살표를 거꾸로 따라가면 이 컴포넌트에 영향을 받는 컴포넌트를 찾을 수 있음

Presenters 컴포넌트를 만드는 개발자가 테스트를 하고 싶다면 현재 사용하는 버전의  Interactors, Entities를 사용해 빌드하면 됨
(다른 컴포넌트는 필요하지 않음)

시스템 전체를 릴리스해야 하면 상향식으로 Entities → Database, Interactors → Presenters, View ~ 순으로 진행
구성요소 간의 의존성을 파악하고 있으면 시스템을 빌드하는 방법을 알 수 있음

###### 순환이 컴포넌트 의존성 그래프에 미치는 영향

Entities의 클래스 중 한 개가 Authorizer를 사용하게 되면, 순환 의존성이 발생함

이 변화로 인해, Entities-Authorizer-Interactors는 하나의 거대한 컴포넌트가 됨
모두 항상 동일한 릴리스를 사용해야 하고 1개의 컴포넌트를 테스트하기 위해 다른 컴포넌트까지도 빌드하고 통합해야 함

이처럼 순환이 생기면 컴포넌트를 분리하기 어려워지고 빌드 관련 이슈가 기하급수적으로 증가하게 됨
어떤 순서로 컴포넌트를 빌드해야 할 지 파악하기 어렵기 때문에 문제가 발생하기 쉬움

###### 순환 끊기

1. 의존성 역전 원칙 적용

   ![14장 컴포넌트 결합](https://blog.kakaocdn.net/dn/bUJzfE/btqCclf8bGy/KcEpob08VSYtjD88KUyrTk/img.png)

   User가 필요로하는 메서드를 제공하는 인터페이스를 생성하고 이 인터페이스를 Athorizer가 상속받음
   둘의 의존성을 역전시킴으로써 순환을 끊을 수 있음

2. Entities-Authorizer 모두 의존하는 새로운 컴포넌트를 생성하고 두 컴포넌트가 모두 의존하는 클래스를 새로운 컴포넌트로 이동

요구사항이 변경되면 컴포넌트와 의존성 구조도 변경될 수 있기 때문에 순환이 발생하는지 항상 관찰해야 함

###### 하향식 구조

**컴포넌트 구조는 하향식으로 설계될 수 없음** 

컴포넌트 의존성 다이어그램은 애플리케이션의 기능이 아니라 빌드 가능성, 유지보수성을 보여줌
빌드할 소프트웨어가 없다면 필요가 없기 때문에 컴포넌트 구조는 프로젝트 초기에 설계할 수 없음

개발이 진행되면서 의존성 관리에 대한 요구가 점점 늘어나게 되고 SRP, CCP에 관심을 갖게 됨
컴포넌트 의존성 그래프로 컴포넌트 아키텍처를 안정적으로 만들고자 하게 됨
이후 재사용성에 초점을 맞추면 컴포넌트를 조합하는 과정에서 CRP 원칙이 영향을 미치고 순환이 발생하면 ADP가 적용됨
이 과정에서 컴포넌트 의존성 그래프는 계속 변화하고 성장함

아무런 클래스도 설계하지 않은 상태에서 컴포넌트 의존성 구조를 설계하려고 하면 실패하기 쉬움
공통 폐쇄나 재사용 가능한 요소에 대해 알지 못하며, 순환 의존성이 거의 확실히 발생하게 되기 때문에 의존성 구조는 시스템의 논리적 설계에 따라 계속 변화할 것

##### SDP: 안정된 의존성 원칙

> **더 안정적인 쪽에 의존하라**

설계는 결코 정적일 수 없고 변경이 불가피 하기 때문에 폐쇄 원칙을 준수해 특정 유형의 변경에만 반응하도록 만들 수 있음
이처럼 컴포넌트 중 일부는 변동성을 지니도록 설계됨

**변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존해서는 안됨** → 한 번 의존하게 되면 변동성이 큰 컴포넌트도 변경이 어려워짐

###### 안정성

안정성은 변화가 발생하는 빈도가 아니라 쉽게 변동할 수 있는지에 관한 성질임

소프트웨어 컴포넌트는 해당 컴포넌트에 의존하는 컴포넌트가 많을수록 안정적이라고 볼 수 있음
사소한 변경이라도 의존하는 모든 컴포넌트를 만족하면서 변경하려면 상당한 노력이 들기 때문

###### 안정성 지표

컴포넌트로 들어오고 나가는 의존성의 개수를 세어서 컴포넌트가 위치상 어느 정도의 안정성을 가지는지 계산할 수 있음

- Fan-in: 컴포넌트 내부의 클래스에 의존하는 외부 클래스 갯수
- Fan-out: 컴포넌트 외부에 의존하는 내부 클래스 갯수
- 불안정성(I 지표): Fan_out/(Fan_in+Fan_out)

컴포넌트의 I 값은 그 컴포넌트가 의존하는 다른 컴포넌트들의 I보다 커야함
→ 의존성 방향으로 갈수록 I 지표 값이 감소해야 함

###### 모든 컴포넌트가 안정적이어야 하는 것은 아니다

모든 컴포넌트가 최고로 안정적이면 변경이 불가능하므로 바람직한 상황이 아님
컴포넌트를 설계할 때에는 불안정한 컴포넌트와 안정된 컴포넌트가 다 존재하는 상황을 기대함

![그림 14.8 세 컴포넌트로 구성된 시스템의 이상적인 구성](https://uchanlee.dev/static/dc69bd12c60636285300481d41f78c93/0a47e/image-14.8.png)

이상적인 구조의 컴포넌트 다이어그램
불안정한 컴포넌트를 위에 두면, SDP를 위반하는 상태를 확인하기 쉬움 

여기에서 Stable 아래 Flexible이라는 새로운 컴포넌트를 추가하게 되면 SDP 위반이 발생
(Stable의 I지표가 Flexible의 I지표보다 더 작기 때문)

이 문제를 해결하기 위해 DIP를 도입할 수 있음
Stable에서 사용할 메서드를 선언한 추상 컴포넌트를 생성해 Flexible이 이 인터페이스를 구현하도록 함
→ Stable의 Flexible에 대한 의존성을 끊어 의존성이 I가 감소하는 방향으로 구성됨

###### 추상 컴포넌트

오로지 인터페이스만을 포함하는 컴포넌트를 생성하는 방식인 추상 컴포넌트는 상당히 안정적이며, 따라서 덜 안정적인 컴포넌트가 의존할 수 있는 이상적인 대상

정적 타입에서는 자주 사용되지만, 동적 타입 언어에는 의존성 역전에 인터페이스 선언/상속이 필요 없기 때문에 추상 컴포넌트가 사용되지 않음

##### SAP: 안정된 추상화 원칙

> **컴포넌트는 안정된 정도만큼만 추상화되어야 한다.**

고수준 아키텍처나 정책 결정과 관련된 소프트웨어는 자주 변경되어선 안 됨
고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 컴포넌트에 위치해야 하고 불안정한 컴포넌트는 변동성이 큰 소프트웨어만을 포함해야 함

하지만 고수준 정책을 안정된 컴포넌트에 위치시키면 그 정책을 포함한 소스 코드는 수정이 어려워지고 시스템 전체가 유연성을 잃음
→ **OCP를 적용해 안정되면서도 변경에 대응할 수 있을 정도로 유연하게 만들 수 있음**
→ 추상 클래스

###### 안정된 추상화 원칙

안정성과 추상화 정도 사이의 관계를 정의함
안정된 컴포넌트는 추상 컴포넌트여야 하며, 안정성이 컴포넌트를 확장하는 일을 방해해서는 안됨
불안정한 컴포넌트는 쉽게 변경될 수 있도록 구체 컴포넌트여야 함

안정적인 컴포넌트는 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 함ㅋ
안정된 컴포넌트가 확장이 가능해지면 유연성을 얻게 되고 아키텍처를 과도하게 제약하지 않게 됨

**SAP, SDP를 결합하면 컴포넌트에 대한 DIP와 같아짐**
DIP는 클래스에 대한 원칙이고 클래스는 추상적이거나 아니거나 둘 중 하나이지만 컴포넌트는 어떤 부분은 추상적이고 어떤 부분은 안정적일 수 있음

