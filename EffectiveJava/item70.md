## Effective Java 3/E

#### Item 70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

- 문제 상황을 알리는 타입(Throwable)
  - 검사 예외
  - 런타임 예외
  - 에러

-----

##### 검사예외

- 호출하는 쪽에서 복구하리라 여겨지는 상황
- 검사 예외를 던져서 호출자가 catch로 잡아 처리하거나 더 바깥으로 전파하도록 강제하게 됨
- 복구할 수 있는 조건일 때 발생하기 대문에 호출자가 예외 상황에서 벗어나는 데 필요한 정보를 알려주는 메서드를 함께 제공해 줘야 함

------

##### 비검사 예외

- 런타임 예외, 에러

- 동작 측면에선 다르지 않음. 프로그램에서 잡을 필요가 없거나, 잡아선 안됨

  > 복구가 불가능하거나 더 실행해봐야 득보다는 실이 많음

###### 런타임 예외

- 프로그래밍 오류를 나타낼 때 사용

- 대부분의 경우 전제 조건을 만족하지 못했을 때 사용(API의 명세에 기록된 제약을 지키지 못했을 때)

  > 배열의 인덱스는 0 ~ 배열크기-1 사이의 값을 가져야 함
  > IndexOutOfBoundsException은 이 전제조건을 만족하지 못했을 때를 의미 

- **일시적인 문제이거나 복구할 수 있는 상황에는 검사 예외를 사용하고 아닐 경우에는 런타임 예외를 사용**

  > 확신하기 어려우면 비검사 예외를 택하는 것이 나음

###### 에러

- JVM이 자원 부족, 불변식 깨짐 등 더 이상 수행을 계속할 수 없는 상황

- Error 클래스를 상속해 하위 클래스를 만드는 것은 자제해야 함(업계 규약)

  → 직접 구현하는 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 함
  → AssertionError을 제외하고는 throw로 던져서도 안됨

###### 위에 속하지 않는 Custom throwable

- 암묵적으로 일반적인 검사 예외처럼 다루지만 **사용해서는 안됨**
- 정상적인 검사 예외보다 나을 게 없으면서 사용자를 헷갈리게 할 수 있음

-------

###### 예외의 사용

- 예외도 어떤 메서드라도 정의할 수 있는 객체임

- 예외의 메서드는 주로 예외를 일으킨 상황에 관한 정보를 코드 형태로 전달하는 데 사용됨

  → 이런 메서드가 없을 경우 사용자가 오류 메시지를 파싱해서 사용해야 하는데 안좋은 습관!

- throwable의 클래스들은 대부분 오류 메시지 포맷을 정의하지 않기 때문에 JVM, 버전에 따라 포맷이 달라질 수 있음

  → 환경에 따라 동작하지 않는 경우가 생길 수 있음

