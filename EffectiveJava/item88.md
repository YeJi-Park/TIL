## Effective Java 3/E

#### Item 88. readObject 메서드는 방어적으로 작성하라

- item 50에서 사용한 Period 클래스를 직렬화 한다고 했을 때, Period 객체의 물리적 표현이 논리적 표현과 부합하므로 기본 직렬화 형태를 사용할 수 있음

  → Serializable만을 추가하는 것은 불변식을 깨지게 할 수 있음

-----

##### readObject

- 실질적으로 또 다른 public 생성자이기 때문에 보통의 생성자처럼 주의깊게 사용해야 함

  - 인수가 유효한지 검사

  - 매개변수를 방어적으로 복사

    → 이러한 작업을 수행하지 않으면 공격자가 손쉽게 클래스의 불변식을 깨뜨릴 수 있음

- 매개변수로 바이트 스트림을 받는 생성자

###### 정상적이지 않은 형태(허용되지 않은)의 객체 생성

- 보통의 경우 바이트 스트림은 정상적으로 생성된 인스턴스를 직렬화해서 만들어짐
- 불변식을 깨트릴 의도로 임의 생성한 바이트 스트림(정상적인 생성자로는 만들 수 없는 객체)를 생성할 수 있음

- 이런 공격을 막으려면 **readObject 메서드가 defaultReadObject를 호출한 다음 역직렬화된 객체가 유효한지 검사해야 함**
- 유효성 검사에 실패하면 InvalidOjbectException을 던지게 하여 잘못된 역직렬화를 막을 수 있음

###### 가변 공격

- 정상 인스턴스에서 시작된 바이트 스트림 끝에 private 필드로의 참조를 추가하면 가변 인스턴스를 만들어낼 수 있음

- 공격자가 ObjectInputStream에서 인스턴스를 읽은 후 스트림 끝에 추가된 '악의적 객체 참조'를 읽어 Period 객체의 내부 정보를 얻을 수 있음

  → 이렇게 얻어낸 인스턴스를 통해 내부를 수정할 수 있으므로 인스턴스는 더 이상 불변이 아니게 됨

- 공격자는 이처럼 불변 인스턴스를 가변으로 만들어 이 인스턴스가 불변이라고 가정하는 클래스에 넘겨 보안문제를 일으킬 수 있음

  → **역직렬화를 수행하는 readObject 메서드에서 클라이언트가 소유해서는 안 되는 객체 참조를 갖는 필드를 모두 방어적 복사해야 함**

  

  ```java
  private void readObject(ObjectInputStream s){
  		s.defaultReadObject();
  		start = new Date(start.getTime());
  		end = new Date(end.getTime());
  		
  		if(star.compareTo(end) > 0) {
  			throw new InvalidObjectException(start + " after " + end);
  		}
  	}
  ```

  - 방어적 복사를 유효성 검사보다 앞서 수행

  - Date의 clone이 아니라 new로 생성

    > final 필드는 방어적 복사가 불가능하니 주의해야 함
    > readObject 메서드를 사용하려면 start, end 필드에서 final 한정자를 제거해야 함

-----

###### 기본 readObject 메서드를 사용해도 좋은 경우

- transient 필드를 제외한 모든 필드의 값을 매개변수로 받아 유효성 검사 없이 필드에 대입하는 public 생성자를 추가해도 괜찮을 때만 사용
- 위 경우를 제외하고는 커스텀 readObject 메서드를 만들어 모든 유효성 검사와 방어적 복사를 수행해야 함
- 또는 **직렬화 프록시 패턴**을 사용해야 함
- final이 아닌 직렬화 가능 클래스라면 readObject 메서드도 재정의 가능 메서드를 호출해서는 안됨
  - 해당 메서드가 재정의되면, 하위 클래스의 상태가 역직렬화되기 전에 하위 클래스에서 재정의된 메서드가 실행되어 오작동할 수 있음

