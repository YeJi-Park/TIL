## Effective Java 3/E

#### Item 67. 최적화는 신중히 하라

- 최적화는 좋은 결과보다는 해로운 결과로 이어지기 쉬움

------

- **빠른 프로그램보다는 좋은 프로그램을 작성할 것**

  - 좋은 프로그램은 정보 은닉 원칙을 따르므로 개별 구성요소의 내부를 독립적으로 설계할 수 있음

    → 시스템의 나머지에 영향을 주지 않고도 각 요소를 다시 설계할 수 있음

  - 구현 상의 문제는 나중에 최적화해 해결할 수 있지만 아키텍처의 결함이 성능을 제한하는 경우라면 시스템 전체를 다시 작성해야 하므로 설계 단계에서 성능을 염두에 두어야 함

- **성능을 제한하는 설계를 피하라**

  - 외부시스템과의 소통, 컴포넌트 간의 소통은 완성 후 변경이 어려움

    > API, 네트워크 프로토콜, 영구 저장용 데이터 포맷 등

  - 변경이 어려움과 동시에 성능을 제한할 수 있으므로 설계 단계에서 고려해야 함

- **API를 설계할 때 성능에 주는 영향을 고려하라**

  - public 타입을 가변으로 만들 경우 불필요한 방어적 복사를 유발할 수 있음

  - 컴포지션으로 해결할 수 있음에도 상속 방식으로 설계한 public 클래스는 상위 클래스에 종속되며, 성능 제약도 물려받음

  - 인터페이스가 있는데 구현 타입을 사용할 경우 특정 구현체에 종속되게 하므로 성능 제한이 될 수 있음

    > java.awt.Componment는 getSize에 Dimension 인스턴스를 반환하므로 getSize를 호출할 때마다 방어적 복사를 해야 함

- 최적화 시도 전후로 성능을 측정하라

  - 최적화 기법이 성능을 높이기 어렵고, 나쁘게 할 때도 많음
  - 프로파일링 도구: 개별 메서드의 소비 시간과 호출 횟수와 같은 런타임 정보를 제공
  - jmh: 자바 코드의 상세한 성능을 알기 쉽게 보여주는 마이크로 벤치마킹 프레임워크

- 자바는 구현 시스템, 릴리즈, 프로그램마다 성능이 다르므로 최적화를 각각에서 측정해야 함

