## Effective Java 3/E

#### Item 71. 필요 없는 검사 예외 사용은 피하라

- 검사 예외는 발생한 문제를 프로그래머가 처리하여 안전성을 높이게 해주지만, 과하게 사용하면 쓰기 불편해짐
- 어떤 메서드가 검사 예외를 던질 수 있다고 선언되면, caller는 catch 블록을 두어 예외를 처리하거나 다시 던져야 함
- 스트림 내부에서는 검사 예외를 던지는 메서드를 사용할 수 없기 때문에 부담이 커짐

------

- API를 제대로 사용해도 발생할 수 있는 예외거나, 프로그래머가 의미 있는 조치를 취할 수 있다면 검사예외
  그 외에는 비검사 예외를 사용해야 함

```java
try{
    doSomething();
}catch( TheCheckedException e){
    throw new AssertionError(); // 일어날 수 없음
}

try{
    doSomething();
}catch( TheCheckedException e ){
    e.printStackTrace();
    System.exit(1);
}
```

> 이 예시가 무슨 의미인지 모르겠다..

-----

###### 검사예외 회피

- 메서드가 단 하나의 검사 예외만 던질 때에는 그 예외 때문에 try 블록을 추가해야 하고 스트림에서 직접 사용하지 못하게 되므로 검사 예외를 던지지 않는 방법이 있는지 고민해봐야 함

- 적절한 결과 타입을 담은 옵셔널을 반환해 검사 예외를 피할 수 있음

  > 예외가 발생한 이유를 알려주는 부가정보를 담을 수 없음

- 검사 예외를 담는 메서드를 2개로 쪼개 비검사 에외로 바꿀 수 있음

  ```java
  // 리팩토링 전
  try{
      obj.action(args);
  }catch(TheCheckedException e){
      // 예외 처리
  }
  
  // 리팩토링 후
  if(obj.actionPermitted(args){ // 상태검사 메서드
      obj.action(args);
  }else{
      // 예외상황 처리
  }
  ```

  - 리팩터링 후는 더 유연하게 사용 가능함
  - 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 상태가 변할 수 있다면 이 리팩터링은 적절하지 않음

-----

- 궁금증
  - 스트림에서 직접 사용하지 못하는 거라면, 간접적으로는 사용할 수 있나?