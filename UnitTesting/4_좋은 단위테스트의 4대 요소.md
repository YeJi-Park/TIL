## Unit Testing

### 04. 좋은 단위 테스트의 4대 요소

테스트는 최소한의 유지비로 최대 가치를 끌어내야 한다. 이를 위해서는 ①가치 있는 테스트를 식별하고 ②가치 있는 테스트를 작성해야 한다.

좋은 테스트는  ①회귀 방지 ②리팩터링 내성 ③빠른 피드백 ④유지 보수성 4가지 특성을 가진다.

---

<br>

#### 4.1 좋은 단위 테스트의 4대 요소 자세히 살펴보기

##### 4.1.1 회귀 방지

- 회귀: 소프트웨어 버그로, 코드를 수정한 후 기능이 의도한 대로 작동하지 않음

**코드베이스가 커질수록 더 위험이 커지기 때문에 회귀에 대해 효과적인 보호를 개발하는 것이 중요하다.**

- 회귀방지 지표에 대한 테스트 점수
  - 테스트 중에 실행되는 코드의 양: 실행되는 코드가 많을수록 테스트에서 회귀가 나타날 가능성이 높음
  - 코드 복잡도: 비즈니스 로직을 담은 복잡한 코드에서 발생한 버그가 더 큰 문제를 일으키기 때문에 이런 코드를 테스트해야 함
  - 도메인 유의성(?): 코드의 외부 의존성도 SW 작동에 영향을 미치기 때문에 테스트 범주에 포함시켜야 함

**이 지표를 극대화 하기 위해서는 가능한 한 많은 코드를 실행하는 것을 목표로 해야한다.**

##### 4.1.2 리팩터링 내성

테스트를 실패하지 않고 기존 코드를 리팩터링할 수 있는 지에 대한 척도

리팩토링을 했을 때, 기능에는 문제가 없지만 테스트는 실패하는 경우가 있다.(*거짓 양성False positive*) 거짓 양성이 많아지면 테스트의 신뢰도가 떨어지고 테스트를 수정하고자 하는 의지가 적어질 수 있어 프로젝트 성장에 방해가 될 수 있다.

거짓 양성이 적게 발생할 수록 높은 리팩터링 내성을 가졌다고 볼 수 있다.

##### 4.1.3 무엇이 거짓 양성의 원인인가?

테스트와 SUT의 구현 사항이 많이 결합할 수록 거짓 양성이 생길 확률이 높다. **테스트는 최종 사용자의 관점에서 SUT가 의미 있는 결과를 내보내는지만 검증해야 한다.**

SUT의 구현과 결합된 테스트는 회귀 발생 시 조기 경고를 제공하지 않고, 리팩터링에 대한 의지를 방해한다.

##### 4.1.4 구현 세부 사항 대신 최종 결과를 목표로 하기

SUT의 로직이 아니라 최종 사용자에게 의미 있는 결과를 검증해야 한다. (HTML 렌더러의 경우 메시지가 표시되는 방식)

테스트를 수정하더라도 새 매개변수를 추가하는 등의 동작을 하면 거짓 양성이 발생할 수 있다. (동작에는 변화가 없기 때문에 거짓 양성) 하지만 이런 거짓 양성은 컴파일 오류를 내기 때문에 발견하기 쉽다. 

- 좋지 않은 거짓 양성: 컴파일 에러를 내지 않는 오류, 타당한 버그일 수도 있기 때문에 확인하는 과정이 필요함



---

<br>

#### 4.2 첫 번째 특성과 두 번째 특성 간의 본질적인 관계

프로젝트 초기에는 회귀 방지가 더 중요하고 리팩터링 내성은 바로 필요하지는 않다. 두 특성은 시간이 흐르면서 프로젝트에 영향을 다르게 미치게 된다.

##### 4.2.1 테스트 정확도 극대화

|             | 정상 동작            | 고장                 |
| ----------- | -------------------- | -------------------- |
| 테스트 통과 | 올바른 추론(참 음성) | 2종 오류(거짓 음성)  |
| 테스트 실패 | 1종 오류(거짓 양성)  | 올바른 추론(참 양성) |

테스트 정확도를 향상시키기 위해서 회귀 방지(거짓 음성), 리팩터링 내성(거짓 양성)을 강화해야 한다.

##### 4.2.2 거짓 양성과 거짓 음성의 중요성: 역학 관계

단기적으로는 거짓 양성이 나쁘지 않아보이지만 프로젝트가 성장함에 따라 거짓 양성이 테스트 스위트에 영향을 미치기 시작한다.  

**리팩터링 내성을 신경쓰지 않으면 시간이 지날수록 테스트 신뢰성이 떨어지게 되기 때문에 거짓 양성에도 주의를 기울여야 한다.**



---

<br>

#### 4.3 세 번째 요소와 네 번째 요소: 빠른 피드백과 유지 보수성

- 빠른 피드백: 테스트 속도가 빠르면 테스트를 자주 수행할 수 있기 때문에 버그 수정 비용을 줄일 수 있음
- 유지 보수성
  - 이해 난이도: 테스트 코드의 품질도 제품 코드만큼 중요함
  - 실행 난이도: 외부 종속성이 있다면 의존성을 유지하는데 드는 비용을 고려해야 함

---

<br>

#### 4.4 이상적인 테스트를 찾아서

좋은 단위 테스트의 네가지 특성을 곱해서 테스트의 가치를 결정할 수 있고 이 추정치로 테스트를 유지할지를 결정할 수 있다.
곱이기 때문에 **한 가지라도 0이면 테스트의 가치도 0이 된다.**

테스트 가치의 임계치를 설정하고 이를 충족하는 테스트만 남겨둠으로써 효과적으로 테스트 스위트를 유지할 수 있다.

##### 4.4.1 이상적인 테스트를 만들 수 있는가?

테스트 특성 ①회귀 방지 ②리팩터링 내성 ③빠른 피드백 은 상호 배타적이기 때문에 모든 특성을 최대로 하는 것은 불가능하다. 
네가지 특성 중 하나라도 0을 받는 테스트는 가치가 없기 때문에 어떤 특성도 크게 줄지 않는 방식을 추구해야 한다.

##### 4.4.2 극단적인 사례 1: E2E 테스트

E2E 테스트는 회귀 방지, 리팩터링 내성이 뛰어나지만 속도가 매우 느려 E2E 테스트만으로는 코드베이스를 다루는 게 불가능하다.

##### 4.4.3 극단적인 사례 2: 간단한 테스트

속도가 빠르고 리팩터링 내성도 우수하지만 너무 간단하기 때문에 회귀 방지에는 소용이 없다.

##### 4.4.4 극단적인 사례 3: 깨지기 쉬운 테스트

- 깨지기 쉬운 테스트: 실행이 빠르고 회귀를 잡을 가능성이 높지만 거짓 양성이 높은 테스트

SUT의 내부 구현 사항에 결합되어 거짓 양성을 내기 쉬운 테스트

##### 4.4.5 이상적인 테스트를 찾아서: 결론

세 가지 특성을 모두 완벽하게 충족할 수는 없기 때문에 균형을 맞추는 전략을 취해야 한다. 

리팩터링 내성은 일반적으로 있거나 없거나 둘 중 하나이기 때문에 **리팩터링 내성을 가지고, 회귀 방지/빠른 피드백 중에 절충해서 선택해야 한다.**

---

<br>

#### 4.5 대중적인 테스트 자동화 개념 살펴보기

##### 4.5.1 테스트 피라미드 분해

- 테스트 피라미드: 테스트 스위트에서 유형 간의 비율
  - E2E>통합>단위 순으로 상위 테스트가 사용자 경험에 가깝고 테스트 수는 적어짐

피라미드 내 테스트 유형에 따라 빠른 피드백↔회귀 방지 사이에 선택할 수 있다. 상단으로 갈수록 회귀 방지, 하단에 가까워질 수록 실행 속도를 강조한다.

테스트 유형 간의 비율은 팀과 프로젝트마다 다르지만 일반적으로는 피라미드 형태를 유지해야 한다. (E2E 테스트는 속도가 매우 느리기 때문에 불필요하게 많이 사용해서는 안됨)

> 아주 단순한 어플의 경우(CRUD 동작) 단위 테스트가 유용하지 않으므로 통합 테스트를 사용할 수 있음

##### 4.5.2 블랙박스 테스트와 화이트박스 테스트 간의 선택

- 블랙박스 테스트: 시스템의 내부 구조를 몰라도 기능을 검사할 수 있음. 명세와 요구사항을 위주로 구축됨
- 화이트박스 테스트: 내부 작업을 검증. 소스 코드에서 파생됨→ 더 철저하지만 깨지기 쉬운 테스트

|            | 회귀 방지 | 리팩터링 내성 |
| ---------- | --------- | ------------- |
| 화이트박스 | 좋음      | 나쁨          |
| 블랙박스   | 나쁨      | 좋음          |

**리팩터링 내성은 타협할 수 없기 때문에 블랙박스 테스트를 기본으로 선택해야 한다.** 대신 테스트를 분석할 때에는 화이트박스를 사용해 코드 커버리지와 분기를 확인해야 한다.
