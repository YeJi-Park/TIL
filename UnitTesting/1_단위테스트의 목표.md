## Unit Testing

### 01. 단위 테스트의 목표

단위 테스트의 목표는 ①테스트에 드는 노력을 가능한 한 줄이고 ②테스트에서 오는 이득을 최대화 하는 것이다.

1장에서는 아래의 내용을 다룬다.

- SW 산업에서 단위 테스트의 현황
- 테스트/유지보수의 목표
- 테스트 스위트를 잘 작성하는 방법

---

<br>

#### 1.1 단위 테스트 현황

대부분의 회사에서 단위 테스트는 필수로 간주되고 있고, 대부분의 프로그래머가 단위 테스트의 중요성을 인지하고 있다. 
단위 테스트는 논쟁의 여지 없이, **필수로 적용**해야 한다.

최근에는 단위 테스트의 작성 여부가 아니라, **좋은 단위 테스트란 어떤 것인가?** 에 대해서 논쟁이 이루어지고 있다.

<br>

---



#### 1.2 단위 테스트의 목표

단위 테스트의 목표는 **소프트웨어 프로젝트의 성장을 지속 가능케하는 것**이다.

일반적으로 단위 테스트를 작성하지 않으면 초기에는 프로젝트가 빠르게 성장할 수 있다. (테스트를 작성할 시간에 프로젝트 코드를 작성할 수 있으므로)

하지만 시간이 지나면서 코드에 무질서도가 증가하게 되므로 코드를 수정하는 것이 어려워지고 개발 속도가 감소한다.

- 버그 수정이 또 다른 버그를 양산하거나 새로운 코드가 기존 기능에 영향을 미치는 것이 예시

테스트를 작성하는 것은 초반에는 개발 속도를 느리게 할 수 있지만, 프로젝트를 안정적이고 확장이 쉽도록 만들기 때문에 그 비용을 메울 수 있다.

<br>

##### 1.2.1 좋은 테스트와 좋지 않은 테스트를 가르는 요인

- **단위 테스트를 작성하기만 하는 것이 중요한 게 아니라, 프로젝트에 도움이 되는 테스트를 작성해야 한다.**

  잘못된 단위 테스트는 초반에는 프로젝트에 도움이 되는 것처럼 보일 수 있지만 유지보수와 오류 분석에 도움이 되지 않는다.

- **테스트의 가치와 유지비용을 고려해 작성해야 한다.**
  
  많다고 좋은 것이 아니다. 테스트도 목적이 다를 뿐(애플리케이션의 정확성 유지), 코드의 일부이기 때문에 유지보수 측면에서 비용을 고려해야 한다.
  
  - 비용은 아래 활동에 소요되는 시간으로 측정할 수 있다.
    - 기반 코드가 리팩토링됨에 따라 테스트 코드가 리팩토링되는 데에 필요한 시간
    - 코드 변경 시 테스트가 실행되는 시간
    - 테스트가 잘못된 경고를 발생시킬 경우 처리하는 시간
    - 기반 코드 동작을 이해하기 위해서 테스트를 분석하는 데 투자되는 시간
  - **프로젝트 성장에 필요한 테스트 코드에 집중해야 한다.**

---

#### 1.3 테스트 스위트 품질 측정을 위한 커버리지 지표

- 커버리지 지표: 테스트 스위트가 소스 코드를 얼마나 실행하는지 백분율로 나타냄

**커버리지가 너무 적을 때에는 테스트가 충분하지 않다는 뜻일 수 있지만, 테스트 커버리지가 높다고 해서 좋은 테스트임을 보장하지는 않는다.**

<br>

##### 1.3.1  코드 커버리지 지표에 대한 이해

- 코드 커버리지: 전체 코드 라인 대비 테스트 스위트가 실행한 코드 라인 수

```java
public static bool isStringLong_1(String input) 
{									
	if(input.length() > 5)			  
		return true;				 // 커버 되지 않음 !!
	return false;
}

public static bool isStringLong_2(String input)
{									
	return input.length() > 5;
}

public void Test()
{
	bool result1 = isStringLong_1("abc"); // 중괄호 포함 5라인 중 4라인이 커버돼 80% 커버리지
    bool result2 = isStringLong_2("abc"); // 중괄호 포함 3라인 중 전체가 커버돼 100% 커버리지
    Assert.Equal(false, result1);
    Assert.Equal(false, result2);
}
```

테스트 스위트가 개선된 것이 아니라, 코드가 달라졌다는 이유로 코드 커버리지가 달라진다.
코드 커버리지가 높다고 해도 테스트가 더 좋다는 것을 보장하지는 않는다.

<br>

##### 1.3.2  분기 커버리지 지표에 대한 이해

- 분기 커버리지: 전체 코드 분기 대비 테스트 스위트가 실행한 분기 수

분기를 구현하는 데 얼마나 코드가 필요한 지 고려하지 않고 테스트가 몇 개의 분기를 수행하는지를 확인한다.
위 코드에서는 두 메서드 모두 false 분기(String 길이가 5자 이하)만 검증하므로 50% 분기 커버리지 지표를 가진다.

<br>

##### 1.3.3  커버리지 지표에 관한 문제점

분기 커버리지가 코드 커버리지보다 더 나은 결과이긴 하지만, 테스트 스위트 품질을 이 지표로 판단해서는 안된다.

1. 테스트 대상의 모든 결과를 검증한다고 보장할 수 없다.

   ```java
   public static bool isStringLong(String input)
   {									
   	bool result = input.length() > 5;
       wasLastStringLong = result; 		// 첫번째 행동
       return result;						// 두번째 행동
   }
   
   public void Test()
   {
   	bool result = isStringLong("abc"); // 두번째 행동인 result에 대한 결과만 검증
       Assert.Equal(false, result);
   }
   ```

   위 테스트 메서드는 코드의 100%와 분기의 50%를 커버하지만 메서드의 모든 결과를 검증했다고 볼 수 없다.

   `isStringLong`은 값을 반환하는 동작과 `wasLastStringLong`에 새로운 값을 쓰는 2가지 행동을 하지만 테스트에서는 값을 반환하는 결과만 검증한다.

   ```java
   public void Test()
   {
   	bool result1 = isStringLong("abc"); 
       bool result2 = isStringLong("abcdef"); 
   }
   ```

   이 테스트는 코드 커버리지와 분기 커버리지가 다 100%지만 결과를 검증하지 않기 때문에 쓸모 없는 테스트이다.

   

2. 외부 라이브러리의 코드를 고려할 수 없다.
   테스트 대상이 외부 라이브러리를 사용한다면 그 경로는 고려되지 않는다.

   ```java
   public static int parse(String input)
   {
       return int.Parse(input); // .NET 프레임워크의 int.Parse
   }
   
   public void Test()
   {
       int result = Parse("5");
       Assert.Equal(5, result);
   }
   ```

   분기, 코드 커버리지가 다 100%이지만 프레임워크의 예외처리와 같은 숨겨진 경로는 고려하지 않는다.

   > null 값, 빈 문자열, 너무 긴 문자열, 정수가 아닌 문자열 등을 처리하는 경로

   **커버리 지가 외부 라이브러리 경로를 고려해야 한다는 뜻이 절대 아니라(그래선 안됨!) 지표로는 테스트의 품질을 판단할 수 없다는 의미이다.**

----

#### 1.4 무엇이 성공적인 테스트 스위트를 만드는가?

테스트 스위트의 품질은 정량적으로 판단할 수 있는 것이 아니기 때문에 테스트 스위트의 특성을 보고 판단해야 한다.

- 일반적으로 성공적인 테스트 스위트의 특성
  1. 개발주기에 통합되어 있음
     - 모든 테스트는 개발주기에 통합돼어 있어, 코드가 변경될 때마다 실행되어야 한다.
  2. 코드베이스의 중요한 부분만을 대상으로 함
     - 시스템의 가장 중요한 부분에 테스트가 집중돼고 다른 부분은 간략하게/간접적으로 검증되어야 한다.
     - 통합 테스트는 시스템의 전체적인 동작이 올바른지 테스트하기도 하지만 테스트의 초점은 비즈니스 로직이어야 한다.
     - 이러기 위해서는 도메인 모델(비즈니스 로직이 위치한)이 코드의 중요하지 않은 다른 부분과 분리되어 있어야 한다.
  3. 최소한의 유지비로 최대의 가치를 끌어냄
     - 가치 있는 테스트를 식별해서, 테스트의 가치가 유지비보다 높은 테스트만 스위트에 유지해야 한다.

