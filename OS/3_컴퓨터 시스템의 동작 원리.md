### 운영체제와 정보기술의 원리

#### 3장. 컴퓨터 시스템의 동작 원리

##### 1. 컴퓨터 시스템의 구조

컴퓨터 시스템은 내부/외부장치로 구분할 수 있음

- 내부: CPU/메모리
- 외부: 디스크, 키보드, 네트워크 등 입출력 장치
  - 입출력 장치에도 각각을 제어하는 컨트롤러와 메모리(로컬 버퍼)가 있음

- 협의의 운영체제: 커널, 운영체제의 핵심부로 메모리에 상주하는 부분
- 광의의 운영체제: 커널+시스템 유틸리티

##### 2. CPU 연산과 I/O 연산

[컴퓨터 시스템 구조]((https://github.com/YeJi-Park/TIL/blob/main/OS/images/ch3_01.PNG)

입출력 장치에서 데이터를 읽어오는 경우, 로컬 버퍼에 데이터가 임시로 저장된 후 메모리에 전달됨
→ 입출력 장치의 컨트롤러가 로컬 버퍼에 읽어오는 작업이 끝나면 인터럽트를 발생시켜 CPU에 알림

- 인터럽트Interrupt: 컨트롤러들이 CPU의 서비스가 필요할 때 이를 통보하는 방법
  - CPU에 Interrupt line이 있어, 다음 명령어 실행하기 전에 interrupt 발생했는지 체크하고 발생할 경우 다음 명령어 전에 인터럽트 루틴을 처리함

##### 3. 인터럽트의 일반적 기능

- 인터럽트 처리 루틴(ISR)/인터럽트 핸들러: 인터럽트 발생 시에 이를 처리하는 커널 함수, 다양한 인터럽트에 대해 처리 로직을 정의함

- HW 인터럽트: 타이머, 디스크 컨트롤러 등 HW 장치가 발생시키는 인터럽트로 일반적으로 인터럽트라 하면 이 인터럽트를 의미함
- SW 인터럽트(trap): SW(프로세스)가 발생시키는 인터럽트로 CPU 제어권을 OS에 넘김
  - exception: 프로그램 오류
  - syscall : 프로그램이 커널 함수를 호출

인터럽트가 발생하면 CPU는 인터럽트 벡터를 찾아가 해당 인터럽트와 매핑되는 ISR을 찾고 ISR을 수행함

##### 4. 인터럽트 핸들링

인터럽트가 발생한 경우에 처리해야 할 루틴으로, 
① 프로세스의 현재 상태를 저장(레지스터에 있던 값들이 날아가지 않도록 현재 명령어의 주소 등을 PCB에 옮김)
② 인터럽트 처리
③ PCB의 정보를 CPU 상에 복원

현대 운영체제는 인터럽트가 발생할 때에만 OS가 CPU를 점유하고, 이외에는 사용자 프로그램이 CPU를 점유하고 있음

##### 5. 입출력 구조

[동기식/비동기식 입출력]((https://github.com/YeJi-Park/TIL/blob/main/OS/images/ch3_01.PNG)

- 동기식: IO 요청 후 다음 명령어를 수행하지 않고 IO 작업이 완료될 때까지 기다린 후 제어가 사용자 프로그램에 넘어감
  - 구현 1) IO 작업이 끝날 때까지 기다림
    - 매 순간 IO를 한 프로세스만 요청할 수 있으므로 낭비!
  - 구현 2) IO 작업 완료될 때까지 해당 프로그램에게서 CPU를 뺏어서 다른 프로그램에게 할당
    - 프로세스를 몇 가지 상태로 나누고 blocked state인 프로세스에는 CPU를 할당하지 않는 방식으로 구현
    - 이 경우 여러 프로세스가 한 Device에 요청할 수 있으므로 순서가 엉킬 가능성이 있음 → 장치별로 큐를 두어 순서대로 처리하도록 함
- 비동기식: 작업 완료와 별개로 제어가 사용자 프로그램에 넘어감
  - IO 작업을 요청한 후에 다음 명령어로는 IO와 상관 없는 작업을 수행할 수 있으므로 이런 경우에 비동기식이 사용됨

두 경우 다 I/O 완료는 인터럽트로 알림



##### 6. DMA

IO 장치가 로컬 버퍼에 데이터를 옮기면, CPU가 이 데이터를 다시 메모리로 옮기는 작업을 수행함. 

매 IO 인터럽트 때마다 CPU의 작업이 필요하면 효율성이 떨어지므로 DMA Controller를 둬서 블럭 단위로 메모리에 복사해주는 작업을 수행 시킴



##### 7. 저장장치의 구조

- 주기억 장치RAM: 휘발성 volatile
- 보조기억 장치: 비휘발성으로 파일 시스템 혹은 스왑 영역으로 사용됨
  - 스왑 영역: 메모리는 용량이 적으므로 프로그램 수행에 필요하지 않은 부분은 스왑 영역에 내려놓고 필요할 때 다시 메모리로 올림

##### 8. 저장장치의 계층 구조

[저장장치 계층 구조]((https://github.com/YeJi-Park/TIL/blob/main/OS/images/ch3_01.PNG)

상위로 갈수록 접근 속도가 빠르지만 용량이 적음. 

뻐른 저장장치에 자주 사용될 정보를 저장해(캐싱Caching) 전체 성능을 향상시킬 수 있음

##### 9. 하드웨어와 보안

사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않아야 하므로 운영체제는 mode bit을 사용해 연산의 권한을 확인함

> Modebit 1: 사용자 모드로 위험한 명령어는 실행이 되지 않음
> Modebit 0: 모니터 모드/커널 모드(OS 코드)로 이 모드에서만 특권 명령(보안을 해칠 수 있는 위험한 명령)이 실행 가능

- interrupt/exception이 발생하면 mode bit이 0이 됨
  - e.g) 프로그램 A가 디스크에 입력을 요청(system call)하면 Disk controller한테 요청을 보냐고 CPU는 다른 프로그램을 실행. 
    disk controller가 동작이 끝나면 interrupt를 걸어서 cpu에게 동작이 완료되었음을 알려줌, 
    이 때 수행되는 인터럽트 하드웨어에 의해 모드 비트가 자동으로 0으로 변경됨

##### 10. 메모리 보안 

여러 프로그램이 메모리에 동시에 올라가 있기 때문에 다른 프로그램의 메모리에 접근할 수 없도록 보안 조치가 필요함.

2개의 레지스터(base, limit register)를 사용해 프로세스 메모리의 시작점과 범위를 기록해놓고 해당 범위를 벗어나면 예외를 발생시켜 접근하지 못하도록 종료시킴

##### 11. CPU 보호

프로세스가 CPU를 독점하고 있을 때 운영체제가 따로 이를 빼앗을 방법이 없음

따라서 CPU 독점을 막기 위해서 timer라는 HW를 사용. timer는 일정 주기로 interrupt를 발생시킴. 
운영체제가 timer에 시간을 세팅해서 CPU를 나눠주기 때문에 특정 프로그램이 독점할 수 없게 됨


