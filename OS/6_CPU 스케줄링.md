### 운영체제와 정보기술의 원리

#### 6장. CPU 스케줄링

CPU는 기계어를 실제로 수행하는 컴퓨터의 중앙 처리 장치로 PC(Program counter) 레지스터가 코드의 메모리를 가지고 있어, CPU는 이 주소를 확인해 명령어를 하나씩 수행

CPU는 일반적으로 시스템 내에 1개이므로 효율적으로 관리되어야 함

- CPU에서 실행하는 명령어 종류
  - CPU 내에서 실행되는 명령어 → 빠름, 일반 명령
  - 메모리를 접근하는 명령어 → CPU 명령어보단 느리지만 빠름, 일반 명령
  - 입출력 명령어 → 느림, 특권 명령

사용자 프로그램은 CPU 작업을 수행하거나(CPU Burst), I/O 작업을 수행하는 것(I/O Burst)의 반복으로 이루어짐

- CPU 바운드 프로세스: CPU 작업을 위주로 수행하는 프로세스, 주로 계산 위주의 프로그램
- I/O 바운드 프로세스: I/O 요청이 빈번한 대화형 프로그램



[CPU 버스트-I/O 버스트]((https://github.com/YeJi-Park/TIL/blob/main/OS/images/ch6_01.PNG)

[CPU 버스트 분포]((https://github.com/YeJi-Park/TIL/blob/main/OS/images/ch6_02.PNG)

프로그램마다 CPU를 사용하는 패턴이 다르므로 효율적으로 CPU를 사용하기 위해 스케줄링이 중요함

대부분의 프로세스가 I/O 바운드이며, 소수의 CPU 바운드 프로세스로 구성되어 있으므로 CPU 버스트가 짧은 프로세스가 우선 CPU를 사용할 수 있도록 해야 함

→ I/O 바운드 프로세스의 우선순위가 높아져야 함

##### 1.  CPU  스케줄러

CPU 스케줄러: 준비 상태 프로세스 중에 어떤 프로세스에 CPU를 할당할 지 결정하는 코드

- 스케줄링이 필요한 경우 스케줄러가 준비 큐에 있는 프로세스 중 하나를 선택해 CPU를 할당함

  - ①실행 중이던 프로세스가 I/O 요청 등에 의해 봉쇄 상태가 됨

  - ② 타이머 인터럽트 발생

  - ③ I/O 요청이 완료되어 인터럽트가 발생하고, 프로세스가 봉쇄에서 준비로 바뀜

  - ④ 실행 중이던 프로세스가 종료되는 경우

- 스케줄링 방식

  - 선점형: CPU를 강제로 빼앗을 수 있음 (②③)
  - 비선점형: CPU를 반납하기 전까지는 CPU를 강제로 뺏을 수 없음 (①④)

##### 2. 디스패처

디스패처: 새로 실행될 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경설정을 하는 코드

- 수행중이던 프로세스의 context를 PCB에 저장하고 새로운 프로세스의 문맥을 복원하고 CPU를 넘김

##### 3. 스케줄링의 성능 평가

- 시스템 관점 지표
  - CPU 이용률: 전체 시간 중에서 CPU가 일한 시간의 비율
  - 처리량: 주어진 시간 중 준비 큐에서 기다리던 프로세스 중 끝난 프로세스의 갯수 
- 사용자 관점 지표
  - 소요시간: 프로세스가 CPU를 요청한 시점부터 CPU 버스트가 끝날 때까지의 시간
    - 시작부터 프로세스 종료까지가 아닌, **해당 버스트**가 끝날 때 까지의 시간임
  - 대기 시간: CPU 버스트 기간 중 프로세스가 준비 큐에서 기다린 시간의 합
    - 한 번의 버스트 중에도 여러 번 기다릴 수 있으므로 해당 버스트에서 기다린 시간의 합
  - 응답시간: 준비 큐에 들어온 후 첫 번째 CPU를 획득하기까지 기다린 시간
    - 대화형 시스템에 적합한 성능 척도, 사용자 입장에서 가장 중요함

##### 4. 스케줄링 알고리즘

###### 1) 선입선출 스케줄링(First Come First Served: FCFS)

- 프로세스가 준비 큐에 도착한 순으로 CPU를 할당하고 프로세스가 CPU를 반납할 때까지 기다림
- CPU 버스트가 긴 프로세스가 먼저 도착할 경우 평균 대기시간이 길어지게 됨
  - 먼저 도착한 프로세스의 성격에 따라 효율이 크게 달라짐
- 콘보이 현상Convoy effect:  CPU 버스트가 긴 프로세스보다 짧은 프로세스가 먼저 도착해서 오래 기다려야 하는 현상

###### 2) 최단작업 우선 스케줄링(Shortest Job First:SJF)

- CPU 버스트가 짧은 순으로 할당하는 방식으로 평균 대기시간을 가장 짧게 할 수 있는 알고리즘
- 선점형 방식: 현재 프로세스의 남은 CPU 버스트 시간보다 더 짧은 프로세스가 도착하면 CPU를 빼앗음(Shortest Remaining Time First)
- 비선점형 방식: CPU 버스트가 더 짧은 프로세스가 도착하더라도 현재 프로세스가 CPU를 반납할 때까지 기다림
- 일반적으로는 프로세스들이 각기 다른 시간에 큐에 도착하므로 선점형이 평균 대기시간을 줄이기에 유리함
- 단점
  - 프로세스의 CPU 시간을 미리 알 수 있는 방법이 없음
    - 과거 CPU 버스트 시간을 사용해서 현재 CPU 버스트를 예측하는 방식을 사용하게 됨
  - CPU 버스트가 긴 프로세스는 영원히 CPU를 할당받지 못하는 기아 현상(Starvation)이 생길 수 있음

###### 3) 우선순위 스케줄링(Priority)

- 우선 순위 값이 가장 높은 프로세스에게 CPU를 할당하는 방식으로, 우선 순위 결정은 여러 가지 방식이 있을 수 있음

  > CPU 버스트 시간을 기준으로 하게 되면 SJF와 동일하게 됨

- 비선점형 방식/선점형 방식으로 각각 구현할 수 있음

- SJF처럼 기아현상이 발생할 수 있지만 대기 시간에 따라 우선순위를 높이는 Aging 기법을 사용해 해결할 수 있음

###### 4) 라운드 로빈 스케줄링

- 프로세스가 CPU를 사용할 수 있는 시간을 제한해서 시간이 다 경과하면 CPU를 뺏어 다음 프로세스에게 주는 방식(타이머 인터럽트를 사용)
- 일반적읜 시스템에서는 프로세스의 CPU 버스트 시간이 균일하지 않으므로, 공정하게 스케줄링하는 것이 목적(CPU 버스트 시간이 짧은 프로세스가 빨리 CPU를 얻고 CPU 버스트가 긴 프로세스가 불이익을 당하지 않도록 하는 것)
  - 대화형 프로세스에는 빠른 응답시간을 보장할 수 있으며 소요시간이 짧아짐
  - CPU 버스트가 길어지면 소요시간과 대기시간도 비례해서 길어지게 됨
- CPU의 사용 최대 시간을 너무 길게 잡으면 FCFS와 같은 결과가 되고, 너무 짧게 잡으면 문맥 교환 오버헤드가 커짐

###### 5) 멀티레벨 큐

- 준비 큐를 여러 개로 분할해 관리해서 우선순위가 높은 큐에 있는 프로세스에 CPU를 우선 할당함

  > e.g.) 대화형 작업을 분리하여 별도의 큐로 관리해 우선적으로 CPU를 할당하는 방식

- 2가지의 스케줄링이 필요함

  - 큐 내부의 스케줄링: (전위큐) 응답시간을 짧게 하기 위한 라운드 로빈 (후위큐) 문맥교환 오버헤드를 줄이기 위해 FCFS
  - 큐 간의 스케줄링
    - 고정 우선순위 방식: 큐마다 우선순위를 설정해서 우선순위 순으로 CPU 할당함 → 기아현상 발생할 수 있음
    - 타임 슬라이스: 큐에 CPU 시간을 적절한 비율로 할당함

###### 6) 멀티레벨 피드백 큐

- MLQ와 비슷하지만 프로세스가 다른 큐로 이동할 수 있음
- 큐의 수, 큐의 스케줄링 알고리즘, 상위 큐로 승격시키는 기준 등에 따라 MLFQ가 정의됨
- MLQ는 기아현상이 발생할 수 있음 → 에이징을 구현한 것이 MLFQ

[MLFQ]((https://github.com/YeJi-Park/TIL/blob/main/OS/images/ch6_03.PNG)

- 대표적인 MLFQ 방식
  1) 처음 도착 시에는 우선순위가 높은 큐에 배정
  2) 할당시간 내에 작업이 끝나지 않으면 하위 큐로 내려가게 됨
  3) 상위 큐는 RR, 하위 큐는 FCFS 방식으로 처리함

###### 7) 다중처리기 스케줄링

- CPU가 여러개인 시스템에서의 스케줄링
  - Homogenerous processor: CPU 역량이 비슷한 경우 한 큐에 모든 프로세스를 넣고 순서대로 CPU에 나눠주는 방식
  - 프로세스에 실행 제약조건이 걸려있는 경우 CPU 별로 큐를 따로 사용할 수 있음
- 특정 CPU에 일이 몰리지 않도록 부하 균형이 필요함
- 처리 방식
  - 대칭형: 각 CPU가 알아서 스케줄링을 결정
  - 비대칭형: 한 CPU가 다른 CPU의 스케줄링 및 데이터 접근을 제어

###### 8) 실시간 스케줄링

- 프로세스의 데드라인에 따라 우선순위가 달라짐
- 실시간 시스템
  - 경성: 정해진 시간 안에 작업이 반드시 완료되어야 함 (미사일, 원자로, ...)
    - 데드라인이 얼마 남지 않은 프로세스를 먼저 처리(EDF: Earlist Deadline First)
  - 연성: 데드라인이 존재하지만 지키지 않아도 위험한 상황이 생기지는 않음 (스트리밍 시스템)
    - 데드라인이 존재하는 프로세스에 우선순위를 높게 줌

##### 5. 스케줄링 알고리즘의 평가

- 성능 평가 방법
  - 큐잉 모델: 이론적 방법으로, CPU 처리율과 프로세스 도착율을 입력해 정량적 성능 지표들을 계산
  - 구현 및 실측: 커널의 CPU 스케줄링을 수정해서 실행시간을 측정/비교하는 방식
  - 시뮬레이션: 가상으로 CPU 스케줄링 프로그램을 작성한해 확인하는 방법
