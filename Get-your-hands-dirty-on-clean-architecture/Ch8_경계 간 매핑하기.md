## 만들면서 배우는 클린 아키텍처

### Ch08. 경계 간 매핑하기

#### '매핑하지 않기' 전략

![매핑하지 않기 전략](https://github.com/YeJi-Park/TIL/blob/main/Get-your-hands-dirty-on-clean-architecture/images/08_1.png)

- `AccountController`(웹 계층)가 `SendMoneyUseCase` 인터페이스(어플리케이션 계층)를 호출할 때 `Account` 객체를 인자로 넘겨주면서 같은 모델을 사용함

  > 영속성도 마찬가지로 같은 모델을 사용함

- 웹/영속성 계층에서 특별한 요구사항이 있을 경우 어플리케이션 계층에서는 이 요구사항과 상관이 없더라도 `Account` 도메인 객체가 이 요구사항들을 다뤄야 함
  💡 **단일 책임 원칙을 위반하게 됨**



그러나 '매핑하지 않기' 전략이 더 잘 맞는 프로젝트가 있을 수 있음. 아주 간단한 CRUD 유스케이스의 경우 각 계층이 비슷한 데이터/구조의 모델을 필요로 하므로, 계층 마다 모델을 가지게 되는 것은 낭비가 될 수 있음
💡 **모든 계층이 정확히 같은 구조의, 정확히 같은 정보를 필요로 한다면 '매핑하지 않기' 전략이 완벽한 선택지**

한 전략에서 다른 전략으로 바꾸는 것도 가능하니, 유연하게 생각해서 프로젝트에 적합한 전략을 취하기

#### '양방향' 매핑 전략

![양방향 매핑 전략](https://github.com/YeJi-Park/TIL/blob/main/Get-your-hands-dirty-on-clean-architecture/images/08_2.png)

- 각 계층마다 전용 모델을 사용함(웹/어플리케이션/영속성)
- 장점
  - 다른 계층의 변경이 다른 계층에 영향을 미치지 않기 때문에 각 계층에 적합한 구조의 모델을 가질 수 있음
  - 바깥쪽 계층에서 내부로 매핑을 전달하기 때문에 매핑 책임이 명확함
- 단점
  - 보일러플레이트 코드가 많이 생김
  - 인커밍/아웃고잉 포트가 도메인 객체를 입력값/반환값으로 사용하기 때문에 바깥쪽 계층의 변경에 취약할 수 있음

#### '완전' 매핑 전략

![완전 매핑 전략](https://github.com/YeJi-Park/TIL/blob/main/Get-your-hands-dirty-on-clean-architecture/images/08_3.png)

- **연산마다** 전용 모델을 사용하고, 계층 경계를 넘어 통신할 때에는 각 작업에 특화된 커맨드 모델을 사용함
- 유스케이스마다 다른 커맨드 모델을 사용하기 때문에 여러 유스케이스를 함께 다루는 경우에 비해 유지보수가 훨씬 쉬움
- 웹-어플리케이션 계층 사이에서 사용하는 것을 추천함(어플리케이션-영속성 계층에선 오버헤드가 큼)

💡 매핑 전략은 여러 가지를 섞어 쓸 수 있고, 모든 계층에 동일한 매핑 전략을 사용할 필요는 없음

#### '단방향' 매핑 전략

![단방향 매핑 전략](https://github.com/YeJi-Park/TIL/blob/main/Get-your-hands-dirty-on-clean-architecture/images/08_4.png)

- 모든 계층의 모델 같은 인터페이스를 구현하고, 인터페이스에서 Getter를 제공해서 모델을 캡슐화함
- 인커밍/아웃고잉 포트에서 인터페이스를 입력/반환으로 사용하면 매핑없이 전달할 수 있음

---

#### 언제 어떤 매핑 전략을 사용할 것인가?

- 매핑 전략은 각자 장단점이 있으므로 각 계층마다 적절한 전략을 택해야 함
- 처음에는 간단한 전략으로 시작해서 결합을 떼어내는 전략으로 확장시키는 식으로 전략을 바꾸는 것도 고려해볼 수 있음
- **전략을 결정하려면 팀 내에서 어떤 상황에 어떤 전략을 택할지에 대한 가이드라인 및 근거를 정해야 함**